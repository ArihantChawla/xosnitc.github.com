<!DOCTYPE html>

<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->

<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->

<head>
	<meta charset="UTF-8">
	
	<!-- Remove this line if you use the .htaccess -->
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

	<meta name="viewport" content="width=device-width">
	
	<meta name="description" content="Build a simple opearting system">
	
	<title>Roadmap // eXperimental Operating System</title>
	<link rel="shortcut icon" type="image/png" href="favicon.png">
	
	<!--<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>-->
	<link rel="stylesheet" href="css/style.css">
	
	<!--[if lt IE 9]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
</head>



<body>
<!-- Prompt IE 7 users to install Chrome Frame -->
<!--[if lt IE 8]><p class=chromeframe>Your browser is <em>ancient!</em> <a href="http://browsehappy.com/">Upgrade to a different browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to experience this site.</p><![endif]-->

<div class="container">

	<header id="navtop">
		<a href="index.html" class="logo fleft">
			<img src="img/logo.png" alt="Designa Studio">
		</a>
		
		<nav class="fright">
			<ul><li><a href="index.html" >Home</a></li>
				<li><a href="about.html">About</a></li>
				<li><a href="documentation.html" >Documentation</a></li>
				<li><a href="downloads.html">Downloads</a></li>
				<li><a href="roadmap.html" class="navactive">Roadmap</a></li></ul>
			</ul>
		</nav>
	</header>


	<div class="services-page main grid-wrap">

		<header class="grid col-full">
			<hr>
			<p class="fleft">Roadmap</p>
		</header>


		<aside class="grid col-one-quarter mq2-col-full">
		
			<menu>
				<ol style="list-style-type:decimal">
					<li><a href="#navstage1" class="sec" >Understanding the Filesystem</a></li>
					<li><a href="#navstage2" class="sec">Starting the machine</a></li>
					<li><a href="#navstage3" class="sec">Running a user program</a></li>
					<li><a href="#navstage4" class="sec">Playing with files</a></li>
					<li><a href="#navstage5" class="sec">The Exec System Call</a></li>
					<li><a href="#navstage6" class="sec">Multiprogramming</a></li>
					<li><a href="#navstage7" class="sec">Process System Calls</a></li>
					<li><a href="#navstage8" class="sec">Exception Handling</a></li>
					<li><a href="#navstage9" class="sec">Making a console</a></li>
				
				</ol>
			</menu>
		</aside>
		
		<section class="grid col-three-quarters mq2-col-full">
		
			
			
			<div class="grid-wrap">
			<article  id="navstage1" class="grid col-full">
			<h2>Stage 1: Understanding the Filesystem </h2>
			<p> The first stage of building XOS begins with understanding the underlying XFS Filesystem interface. </p>
			
			<ol>
			<li> Download the XFS-Interface from the <a href="downloads.html">downloads</a> page and compile the program following the instructions given in the page.</li>
			<li> Start by formatting the disk in the XFS interface using <b>fdisk</b> command. A file named <i>disk.xfs</i> is created, which simulates the hard disk.</li>
			<li> Load a data file to the XFS formatted disk from your UNIX machine.  Read about  <a href="xfs-spec.html#navfile" >Files</a> in XFS</li>
			<li> Find out the FAT entry corresponding to the loaded file. Use the <b>copy</b> command to copy FAT entries to a file in your PC. See <a href="xfs-spec.html#navdiskorg">disk organization</a> of XFS Disk.  </li>
			<li> Check the <a href="xos-spec.html#navfiles_fat">FAT entry</a> and find the basic block. Copy it to get the data blocks used by this file.</li>
			<li> Copy the data blocks and display the file </li>
			</ol>


			
			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	
			
			<article  id="navstage2" class="grid col-full">
			<h2>Stage 2: Starting the machine </h2>
			<p> The next stage is to make the machine display <i>"Hello World"</i> on startup.    </p>
			<ol>
			<li>
			Create a "Hello World" program using <a href="spl-spec.html">SPL</a> (System Programmer's Language).
			The code snippet is given below. 
			<div class="syntax"> 
			R0 = "Hello World"; </br>
			print R0 ;</br>
			</div>
			</li>
			<li>
			Load it as the OS startup code to <tt>disk.xfs</tt> using the XFS Interface. 
			</li>
			<li> Download the XSM Simulator from the <a href="downloads.html">downloads</a> page. Unzip the directory.</li>
			<li> Place the <b>xfs-interface</b> directory in same directory as <b>xsm</b> directory. ( or change the <b>DISK_NAME</b>  to the path of <tt>disk.xfs</tt> in <b>disk.h</b> in <b>xsm</b> directory) </li>
			<li> Follow the instructions in README to compile the machine simulator </li>
			<li> cd to xsm directory. Run the machine using the command <tt>./xsm --disable-timer </tt>.
			
			</ol>
			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>			

			<article  id="navstage3" class="grid col-full">
			<h2>Stage 3: Running a user program </h2>
			<p> User programs or application programs are programmed using <a href="apl-spec.html">APL</a> or Application Programmer's Language. In this stage, an application program in APL is compiled and loaded to the disk as the init process. An OS Startup code is written in <a href="spl-spec.html">SPL</a> to load this program to the memory on machine startup. 		  </p>
			<ol>
			<li> Download APL Compiler from the <a href="downloads.html">downloads</a> page. Unzip and install the compiler following the instructions in the README </li>
			<li> Write a program in APL to print all prime numbers lesser than a number taken as input. See <a href="apl-spec.html#navexamples">Examples</a> of APL programs</li>
			<li> Compile your APL program using <b> ./apl < <i>path-to-your-program</i> > </b>. </li>
			<li> Load it to <b>disk.xfs</b> as <b>INIT program</b> using XFS interface </li>
			<li> For for the machine to halt when it runs a user program, <b>INT 7</b> and <b>Exception handler</b> of the <b>disk.xfs</b> must be loaded with a file containing just the <tt>HALT</tt> instruction. 
			<br/><br/>
			</ol>
			<h6>OS Startup Code</h6>
			<ol>
			The executable files in <b>INT 7</b>, <b> Exception Handler</b> and the program to print primes  must be loaded to the memory from the XFS disk by the OS Startup Code when the machine starts. The OS Startup Code must be written in <a href="spl-spec.html">SPL</a>, compiled and loaded to the disk as done in the previous stage. The new OS Startup Code must do the following tasks. </br><br/>
			<li> Load Exception Handler (disk block 1 and memory page 7) and INT 7 (disk block 9 and memory page 15) from  the disk to the memory using<a href="spl-spec.html#navlsstmt" > load</a> instruction.  
			<div class="syntax">
			 load (page_number, block_number);
			</div> </li>
			<li>
			Load the <b>INIT process</b> from the disk to the memory. Load blocks 13-15 from disk to memory pages 16 - 18 in the memory.
			</li>
			<li> 
			Setup page tables for the INIT process in the followin way. (Read about <a href="xsm-spec.html#navaddr"> Address Translation </a>).
		 		<ul>
		 		<li>Set <b>PTBR</b> (Page Table Base Register) to 1024, which is the starting address of process page tables (See <a href="xos-spec.html#navmemorg" >Memory Organization</a>) and <b>PTLR</b> to 4.  </li>
		 		<li> Each page table entry contains 2 words. Set the first word of each entry to corresponding memory address and set the second word (Auxiliary information) as <b>11</b>. Refer <a href="xos-spec.html#navmemmgmt_paging">Paging</a> to see the structure of page table entry. </li>
			<li> Setup entries for memory pages 16 to 18 in the page table as well as one entry for the stack (19th page) </li>
			Setting up the entries of page table can be done in the following way
			<div class="syntax">
			 [PTBR + 0] = 16;  // Entry for memory address<br/>
			 [PTBR + 1] = 11;  // Entry for flag<br/>
			   .	<br/>
			   .	<br/>
			   .	<br/>
			 [PTBR + 6] = 19;  // Memory address of stack <br/>
			 [PTBR + 7] = 11;	<br/>
				</div>
				</li>
				</ul>
			
			<li> The next structure to setup is the INIT's Process Control Block. (See <a href="xos-spec.html#navpromgmt_pcb"> PCB </a> ). The starting address of INIT's PCB is <b>1536</b>. SPL has a <a href="spl-spec.html#navconst">predefined constant</a> <tt>READY_LIST</tt> with this value stored. Setup the PCB with each corresponding entry. 
				<ul>
				<li> Set the 1st word with the PID which is 0 for INIT Process </li>
				<div class="syntax">
				 [READY_LIST + 0] = 0 // Sets the entry for PID as 0
				</div>
				<li> Similarly, <tt>STATE</tt> of INIT process is set to 2 (running) </li>
				<li> The remaining entries need not be set by the OS startup code and will be done in subsequent stages.  </li>
				
				</ul> <br/>
			
			
			<li> Once the control gets transferred to the user program, all addresses are logical addresses. Therefore <b>SP</b> (Stack Pointer) must be set to 3*512 (stack is allocated with logical page number 3). And <b>BP</b> (Base Pointer) is   </li>
			<li> Store 0 in the stack (page number 19 in memory). This value gets stored in IP after an <b>ireturn</b> instruction. 
			<div class="syntax">
			[19*512] = 0;
			</div></li>
			
			<li> Use the <b>ireturn</b> instruction to transfer control to user program. This instruction calls the machine instruction <tt>IRET</tt> which changes privilege mode from KERNEL to USER (See <a href="xsm-spec.html#navmodes">privilege modes</a>). <tt>IRET</tt> then gets the value stored in memory location pointed to by SP which is 0 (See previous step). The logical address 3*512 stored in SP gets translated to get the actual location of the stack. This value is stored in IP (In USER mode, IP has logical addresses) and SP is decremented by one (equivalent to popping the stack). </li> 
		 		
		 		
			</li>
			</ol>
			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	


			<article  id="navstage4" class="grid col-full">
			<h2>Stage 4: Playing with files </h2>
			<p> In this stage, you will implement file system calls  <b>Create, Delete, Open, Close, Seek, Read</b> and <b> Write </b>. The following tasks should be done in this stage </p>
			<h6> Modifying the OS Startup Code</h6>
			<ol>
			<li> Load FAT and Disk Free List from the disk blocks to corresponding memory pages. Refer <a href="xos-spec.html#navmemorg">Memory Organization</a> and <a href="xfs-spec.html#navdiskorg">Disk Organization </a>. </li>
			</li>
			<li>
			Set the <a href="xos-spec.html#navfiles_swoft">System-Wide Open File Table</a> entries to -1 (invalid initially). 	</li>
			<div class="syntax">
			<pre>
alias counter R8;	// R8 - R15 is used by system programmers.
counter = 0;
while ( counter <=  128) do
	[ FILE_TABLE + counter] = -1;
endwhile;						</pre>
			</div>
			<li> Set all words in the <a href="xos-spec.html#navpromgmt_pcb">Per-Process Open-File Table in the PCB</a> of INIT to -1  </li>
			
			<li> 
			<a href="xos-spec.html#navsyscalls_file">File System Calls</a> are implemented in Interrupt 1 (Create & Delete),  2 (Open & Close), 3 (Seek & Read) and 4 (Write) Routines. These 4 interrupt routines must be programmed in SPL, compiled and loaded into the disk in the corresponding locations using the XFS-Interface. These interrupt routines must be loaded from the disk to corresponding memory pages by the OS Startup Code.
			</li>
			</ol>
			Each system call will be invoked from a user program which invokes the <tt> INT </tt> instruction after pushing the registers, arguments and system call number into the stack.  <img src="doc/syscallstack.png" style="width:150%">
			
			<br/><br/>
			An Interrupt  Routine may contain more than system call implementation. The system call number is obtained from the stack (Stack Pointer - 1) and then an <b>if</b> condition is checked for the corresponding system call. The top of the stack is obtained by calculating the physical address of SP. The 6th entry in the Page Table (obtained from PTBR + 6) gives the starting address of the stack, and SP%512 will give the offset in the stack. Adding both will give the absoulte address of SP. 
			<br/><br/>
			<h4>File System Calls</h4>
			<table class="doctable" style="width:50%">
				<tr><th>System Call Name</th><th>System Call #</th><th>Interrupt Routine #</th></tr>
				<tr><td>Create</td>			 <td>1</td>				<td> 1</td> </tr>
				<tr><td>Open</td>			<td>2</td>				<td> 2</td> </tr>
				<tr><td>Close</td>			<td>3</td>				<td> 2</td> </tr>
				<tr><td>Delete</td>			<td>4</td>				<td> 1</td> </tr>
				<tr><td>Write</td>			<td>5</td>				<td> 4</td> </tr>
				<tr><td>Seek</td>			<td>6</td>				<td> 3</td> </tr>
				<tr><td>Read</td>			<td>7</td>				<td> 3</td> </tr>
			</table>

			<br/>
			A skeleton of Interrupt 1 Routine is given below.

			<div class="syntax">
			<pre>
alias absoluteSP R8;
absoluteSP = [PTBR + 6] + SP % 512 ;
.
// Get system call no. from the stack
.
if ( sysCallNo == 1) then
	// Implementation of Create
	.
	.
endif;
if ( sysCallNo == 4) then
	// Implementation of Delete
	.
	.
endif;	</pre>
			</div>

			Now we'll implement the system calls in its corresponding Interrupt Routine Code. <br/><br/>
		

		<h6> Create </h6>
		<i>System Call No</i>: 1 <br/>
		<i>Interrupt Routine No</i>: 1 <br/>
		<i>Arguments</i>: filename <br/>
		<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
		<br/>
		Creates a file with the filename given as argument.

		<ol>
		<li> First of all, the memory copy of the <a href="xfs-spec.html#navdfl">disk free list</a> is searched till the entry for block number 447 to find a free block number (indicated by a 0). Blocks 448 - 511  are reserved for <a href="xfs-spec.html#navdiskorg">swap area</a> which will be used for virtual memory management (<a href="roadmap.html#navstage8">Stage 8</a>). This block is used as the <a href="xfs-spec.html#navfile">basic block</a> of the file to be created. It's entry is set to 1. The block number is stored to a register. If no free block is found return -1 (as done in the previous step). </li>

		<li> The <tt>filename</tt> specified as argument is stored in the stack at absoluteSP - 2. Fetch it and store it to a register. </li>
		<li> The memory copy of the <a href="xos-spec.html#navfiles_fat">FAT</a> is to be searched for the <tt>filename</tt> to check if the file already exists. If it exists return from the sytem call with 0 (success).
		</li>

		<li> Next, the memory copy of the <a href="xos-spec.html#navfiles_fat">FAT</a> is searched for a free entry. A free entry in the FAT is indicated by -1 in the entry for basic block (Word 2 of each FAT entry). If no free entry is found put -1 in the return value space of the stack (absoluteSP - 12, See figure above). Then return to USER Mode using <b>ireturn</b> instruction. Address of FAT is stored in a <a href="spl-spec.html#navconst">predefined constant</a> in <tt>FAT</tt> in SPL. </li>
		<li><tt>filename</tt> and the <tt>free block number</tt> obtained  in the previous steps are stored in the <em>Filename</em> field and <em>basic block number</em> field of the free <a href="xos-spec.html#navfiles_fat">FAT</a> entry respectively.</li>
			<li> The <em>file size</em> field of the FAT entry is initialized to zero.</li>


			<div class="syntax">
				<pre>
alias counter R8;
counter = 0;
while(counter < 512) do
	if([FAT + counter + 2] == -1) then
		.
		// Set the FAT entry 
		.
		break;
	endif;
	counter = counter + 8;
endwhile;

// Return with -1 if there is no free entry
if(counter == 512) then 		
	[absoluteSP - 12] = -1;		
	ireturn;	
endif;</pre>
			</div>
		
		<li> Load the <a href="xfs-spec.html#navfile">basic block</a> from the disk to the <a href="xos-spec.html#navfiles_scratchpad">scratchpad</a>. Each entry of the block list in the basic block is initialized to zero and it is stored back to the disk.</li>	
		<li> The updated copies of FAT and disk free list in the memory are then stored back to the disk.</li>
		
		<li> The return value of this system call is 0 in case of success and -1 in case of failure. The return value is stored in the stack at address absoluteSP - 12.</li>
		<li>Use an <b>ireturn</b> instruction to transfer control back to USER Mode.</li>
		</ol>





		<h6> Open </h6>
		<i>System Call No</i>: 2 <br/>
		<i>Interrupt Routine No</i>: 2 <br/>
		<i>Arguments</i>: filename <br/>
		<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
		<br/>
		Opens a file with the filename given as argument.

		<ol>
			<li> FAT is searched for the <tt>filename</tt> (get the <tt>filename</tt> from stack as explained in the Create system call) . If the entry is not found, -1 is returned. Otherwise, store the index of the FAT entry in a register.</li>

			<li>Then, the <a href="xos-spec.html#navfiles_swoft">System-Wide Open File Table</a> is searched for the FAT Index  found in the previous step. If an entry is found, increment the <a href="xos-spec.html#navfiles_swoft"><tt>File Open Count</tt></a>.</li>

			<li> If an entry is not found with the FAT Index, then search for a free entry in the System-Wide Open File Table. If there are no free entries (indicated by -1 <tt>FAT Index</tt> field), return from the system call with return value -1. Otherwise, store <tt>FAT Index</tt> and set the <tt>File Open Count</tt> field as 1 in free entry found.	</li>

			<li> Store the index of the entry (in System-Wide Open File Table) in a register.</li>

			<li> Every process will have a <a href="xos-spec.html#navpromgmt_pcb">Per-Process File Table</a> in its PCB. This stores the details of files opened by this process. Find the PCB's location from PTBR (It may be directly obtained if there is only one process, however following a general approach to get PCBs will be useful when more than one process starts running). 
				
				<div class="syntax"><tt>  ProcessID = (PTBR - 1024) / 8; </tt></div>
			

			Page Tables start at word address 1024. And size of each <a href="xos-spec.html#navpromgpmt_pagetbl">per-process page table</a> is 8 words. 
			<br/><br/>
				We can find the PCB of the current process using the <tt>ProcessID</tt> calculated in the previous step.
				<div class="syntax"><tt> PCB_Start = READY_LIST + 32 * ProcessID; </tt></div>
				
				(READY_LIST is a <a href="spl-spec.html#navconst">predefined constant</a> in SPL which has value 1536). 
			</li>

			<li>  A free entry is searched in the <a href="xos-spec.html#navpromgmt_pcb">per-process open file table in the PCB</a> of the process. A free entry is indicated by -1 in the first field (Pointer to <a href="xos-spec.html#navfiles_swoft">System-Wide Open File Table</a>). If there are no free entries, -1 is returned by the system call. </li>

			<li> Otherwise, set the <tt>Pointer to System-Wide File Table Entry</tt> field to the index stored in Step 4 and set <tt>LSEEK Position</tt> to 0.  </li>
		
			<li> The index of this entry in the local file table is returned as a return value of the system call. This is known as the file descriptor.</li>
		</ol>


		<h6> Close </h6>
		<i>System Call No</i>: 3 <br/>
		<i>Interrupt Routine No</i>: 2 <br/>
		<i>Arguments</i>: fileDescriptor <br/>
		<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
		<br/>
		Closes a file opened by the process.

		<ol> 
			<li> Get the address of PCB of the process as in the Open System Call implementation.</li>
			<li> Index into the per-process open file table using the argument <tt>fileDescriptor</tt>. Return from the system call with -1 (failure) if the <tt>fileDescriptor</tt> is invalid or its corresponding entry is invalid.</li>
			<li> Using the <tt>Pointer to System Wide Open File Table Entry</tt> field, index to the System Wide Open File Table </tt> and decrement <tt>File Open Count</tt> by one. If it becomes 0, invalidate the entry by setting both the fields to -1. </li>
			<li> Now invalidate the Per-Process Open File Table entry, by setting the fields to -1</li>
			<li> Return from system call with 0 (success).
			 </li>
		</ol>

		<h6> Delete</h6>
		<i>System Call No</i>: 4 <br/>
		<i>Interrupt Routine No</i>: 1 <br/>
		<i>Arguments</i>: filename <br/>
		<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
		<br/>
		Deletes a file in the disk with the filename given as argument.


		<ol>
			<li> Search the memory copy of <a href="xos-spec.html#navfiles_fat">FAT</a> for the <tt>filename</tt> specified as argument. If it is not found, return from the system call with -1 (failure). </li>
			<li> If an entry is found, store the index in a register. </li>
			<li> Search the System Wide Open File Table to see if the file has been opened. If it is opened, return from the system call with -1 (failure) </li>
			<li> Otherwise, follow the steps to invalidate and delete the file <li>
				<ul>
				<li>Load the <a href="xfs-spec.html#navfile"><tt>Basic Block</tt></a> to the <a href="xos-spec.html#navfiles_scratchpad">Scratchpad</a>. </li>
				<li> For each block used by the file (specified in the Basic Block), invalidate the corresponding block's entry (Setting -1) in the memory copy of the <a href="xfs-spec.html#navdf">Disk Free List</a></li>
				<li> Invalidate the entry for the basic block in the Disk Free List by setting -1.</li>
				<li> Invalidate the <a href="xos-spec.html#navfiles_fat">FAT</a> entry by setting -1 in the <tt>Block # of Basic Block</tt> field.</li>
				</ul>
			<li> Store back  the FAT and Disk Free List from the memory to the disk.</li>
			<li> Return from the system call with 0 (success)</li>
		</ol>

		<h6> Write </h6>	
		<i>System Call No</i>: 5 <br/>
		<i>Interrupt Routine No</i>: 4 <br/>
		<i>Arguments</i>: 1) fileDescriptor 2) wordToWrite <br/>
		<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
		<br/>
		Writes a word specified by <tt>wordToWrite</tt> to a file opened by the process.

	  	<ol>
	  		<li> Get the arguments to registers from the stack </li>
			<li> Get the address of PCB of the process. </li>
			<li> Index into the per-process open file table using <tt>fileDescriptor</tt>. Return from the system call with -1 (failure) if the <tt>fileDescriptor</tt> is invalid or its corresponding entry is invalid.</li>
			<li> Otherwise, store the LSEEK position to a register.</li>
			<li> Using the <tt>Pointer to System Wide Open File Table Entry</tt> field, index to the System Wide Open File Table to get the FAT Index Entry.   </li>
			<li> Fetch the <tt>basic block</tt> from the FAT and load it to the scratchpad</li>
			<li> Using LSEEK position find the block number to be written to. Find its location in the disk from the basic block. If entry for the block is invalid, then allocate a new block in the following way.</li>
				<ul>
					<li> Traverse through the memory copy of the <a href="xfs-spec.html#navdfl">Disk Free List</a> till the entry for block 447 to get a free block.
					<li> If no free block is avaliable. Return from the system call, with return value -1 (failure). </li>
					<li> Otherwise, set 1 in the entry for the  free block in the Disk Free List. Update the basic block with this block number. </li> 
					<li> Commit the basic block from scratchpad back to the disk. </li>
					<li> Increment the <tt>file size</tt> in the FAT entry by 1. </li>
					<li> Commit the FAT and Disk Free List from the memory to the disk. </li>
				</ul>
			<li> Fetch this block from the disk to the scratchpad. </li>
			<li> Write the argument <tt>wordToWrite</tt> to this block using the offset calculated using LSEEK position.</li>
			<li> Commit this block back to disk </li>
			<li> Increment LSEEK Position by 1 in the Per-Process Open File Table </li>
	  	</ol>


	  	<h6> Seek </h6>
		<i>System Call No</i>: 6 <br/>
		<i>Interrupt Routine No</i>: 3 <br/>
		<i>Arguments</i>: 1) fileDescripto	r 2) newLseek <br/>
		<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
		<br/>
		Changes the value of LSEEK position of the file to <i>newLseek</i>.

	  	<ol>
	  		<li> Get the arguments to registers from the stack </li>
	  		<li> Get the address of PCB of the process. </li>
			<li> Index into the per-process open file table using <tt>fileDescriptor</tt>. Return from the system call with -1 (failure) if the <tt>fileDescriptor</tt> is invalid or its corresponding entry is invalid.</li>
			<li> Using the <tt>Pointer to System Wide Open File Table Entry</tt> field, index to the System Wide Open File Table to get the FAT Index Entry.   </li>
			<li> Fetch the <tt>file size</tt> of the file from the FAT and store it in a register. </li>
			<li> If value of the argument <tt>newLseek</tt> is between 0 and <tt>file size * block size</tt>, change the <tt>LSEEK</tt>  in the per-process file table to <tt>newLseek</tt>. Return with 0 (indicating success).</li>
			<li> Otherwise, return with -1 (indicating failure). </li>
	  	</ol>

	  	<h6>Read</h6>
		<i>System Call No</i>: 7 <br/>
		<i>Interrupt Routine No</i>: 3 <br/>
		<i>Arguments</i>: 1) fileDescriptor 2) Variable<br/>
		<i>Return Value</i>: 0 (success) and -1 (failure) </br>
		<br/>
		Reads a word from a file to the variable passed as argument

	  	<ol>
	  		<li> Get the arguments to registers from the stack </li>
			<li> Get the address of PCB of the process. </li>
			<li> Index into the per-process open file table using <tt>fileDescriptor</tt>. Return from the system call with -1 (failure) if the <tt>fileDescriptor</tt> is invalid or its corresponding entry is invalid.</li>
			<li> Otherwise, store the LSEEK position to a register.</li>
			<li> Using the <tt>Pointer to System Wide Open File Table Entry</tt> field, index to the System Wide Open File Table to get the FAT Index Entry.   </li>
			<li> Fetch the <tt>basic block</tt> from the FAT and load it to the scratchpad
			</li>
			<li> Using LSEEK position find the block number to be read from. Find its location in the disk from the basic block. If entry for the block is invalid, return with value -1 (indicating failure).</li>
			<li> Else,  fetch this block from the disk to the scratchpad. </li>
			<li> Read from this block using the offset calculated using LSEEK position. </li>
			<li> This value is stored in the stack in position of Argument 2. Store the word read to absoluteSP - 2.</li>
			<li> Return with 0, indicating success </li>
	  	</ol>

			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	
			

			<article  id="navstage5" class="grid col-full">
			<h2>Stage 5: The Exec System Call</h2>
			<p>  
			The <a href="xos-spec.html#navsyscalls_process">Exec system call</a> is used to load and run a new process from a currently running process. The current process is overwritten by new process i.e. the process data structures of the current process is used by the new process. </br>
			<i>System Call No</i>: 9 <br/>
			<i>Interrupt Routine No</i>: 6 <br/>
			<i>Arguments</i>: filename <br/>
			<i>Return Value</i>: 0 (success) and -1 (failure) </br>
		
			 </p>
			 The Interrupt 6 Routine is to be programmed in SPL, compiled and loaded to the disk. 
			 <b>OS Startup Code</b> is modified to load Interrupt Routine 6 from the disk to memory. </br>

			 The Interrupt 6 Routine performs the following actions.
			 <ol>
		 		<li> Get the filename to a register from the stack </li>
		 		<li> Search for the filename in the memory copy of FAT. If it doesn't exist return -1 (indicating failure). </li>
		 		<li> Otherwise fetch the basic block (location is obtained from FAT) and place it in the <a href="xos-spec.html#navfiles_scratchpad">scratchpad</a>.
		 		</li>
		 		<li> Load the blocks of the file (a maximum of 3 blocks) to the memory in pages of INIT process (16-18). INIT is the currently running process which issues an Exec system call.</li>
		 		<li> Close all files opened by the current process by following the steps in <b>Close()</b> system call </li>
		 		<li> SP is reset to 3*512.  </li>
		 		<li> 0 is stored in 19*512 (physical address of the stack) to set IP by the <b>ireturn</b> instruction </li> 
				<li> Return from the system call with 0 (indicating success).</li>
			 </ol>

			 <b>Exec</b> system call can be tested out by modifying the INIT program, by adding an <a href="apl-spec.html#navexec">Exec</a> call in it.

			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	
			



			<article  id="navstage6" class="grid col-full">
			<h2>Stage 6: Multiprogramming</h2>
			<p>  <a href="xos-spec.html#navpromgmt_multiprog">Multiprogramming</a> refers to running more than one process simultaneously. In XSM, the timer interrupts after every instruction and the control is passed to Page 8, i.e. the timer interrupt routine.  </p>
			Run the machine  without disabling the timer. <br/>
			<tt> ./xsm </tt>

			<p>The task to be done in this stage, is to program the Timer Interrupt in SPL, compile it and load it to the disk. </p>


			The timer interrupt routine must perform the following actions:
			<ol>
				<li> Find the ProcessID or PID using the PTBR. </li>
				<li> Using the PID find the PCB of the process. Store the values of the current process in its <a href="xos-spec.html#navpromgmt_pcb">PCB</a> as shown below.</li>
					<div class="syntax">
						<pre>
[ PCB_Start + 0 ] = ProcessID;		//PID
[ PCB_Start + 1 ] = 1 			// STATE : Waiting for the CPU
[ PCB_Start + 2 ] = BP 					
[ PCB_Start + 3 ] = SP            	
[ PCB_Start + 4 ] = [absoluteSP - 1] 	// IP gets stored in SP by machine
[ PCB_Start + 5 ] = PTBR	
[ PCB_Start + 6 ] = PTLR		
[ PCB_Start + 7 ] = R0			
	.
	.
[ PCB_Start + 14] = R7			</pre>	</div>	

				<li>Scan the <a href="xos-spec.html#navpromgmt_readylist">Ready List of PCBs</a> in a circular manner from the PCB of current process to check for the next process with STATE 1 (Waiting for the CPU). Store the address of the PCB found in a register.
				</li>
				<li> Load the fields from this  PCB  to the corresponding registers.	</li>
				<li> Find the physical address of SP corresponding to newly found PCB. Store IP from this PCB to the location pointed by the physical address of SP. </li>
				<li> Use <b>ireturn</b> instruction to return to USER Mode</li>
	
			</ol>

			However to test the timer interrupt, you must have more than one program present in the memory. The programs will run in an interleaved fashion when the timer itnerrupt is working perfectly. 

			<ol>
				<li> Write and compile 2 APL programs,
					<ul>
						<li> To print all even numbers from 1 to n (taken as input)</li>
						<li> To print all odd numbers from 1 to n (taken as input)</li>
					</ul>
				<li> Load one of the programs as INIT and the 2nd program as an executable to <b>disk.xfs</b></li>
			</ol>
			<b> OS Startup Code </b>
			<ol>
				<li> Modify the startup code, to load both the programs, one as INIT (already done in Stage 2) and other from locations 20 to 22 and page 23 for stack. </li>
				<li> Setup the Per-Process Page Tables and PCB for the 2nd process as done in Stage 2. See <a href="xos-spec.html#navmemorg">Memory Organization</a> to get the locations of the page table and PCB of the 2nd process </li>
				<li> Load the Timer Interrupt Routine from the disk to the memory. </li>
			</ol> 



			Run the machine without disabling the timer.

			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	
			
			<article  id="navstage7" class="grid col-full">
			<h2>Stage 7: Fork , Exit and Halt System Calls </h2>

			<h6>Fork</h6>
			<i>System Call No</i>: 8 <br/>
			<i>Interrupt Routine No</i>: 5 <br/>
			<i>Arguments</i>: None<br/>
			<i>Return Value</i>: PID of the process created (success) or -1 (failure)</br>

			<a href="xos-spec.html#navsyscalls_process"> Fork </a> system call is used to replicate the process which invoked this system call in the memory. <br/></br>
			Interrupt 5 Routine must be programmed in SPL, compiled and loaded to disk. It must perform the following tasks.
		  	<ol>
			<li> The <em>Ready list</em> of PCBs is traversed to find a PCB with State 0 (terminated).</li>
			<li> If no such PCB is found, -1 is returned. </li>
			<li> The index of the PCB in the Ready List is the PID of new process created. It is stored in a register.</li>
			<li> The pages used by the parent process is replicated in the following way</li>
				<ul>
					<li> The page table of the parent process is checked to count the number of valid pages. The <a href="xos-spec.html#navmemmgmt_mfl">memory free list</a> is checked to find an equal number of free pages. If this check fails, return with -1 indicating failure. </li> 
					<li> Otherwise an equal number of pages are allocated by updating the memory free list.</li>
					<li> Make corresponding entries in the child process' page table. The child's PTBR (address of its page table) is computed using PID stored in Step 3 </li>
				</ul>
			<li> The current register values of the parent process are (except PTBR)  copied to the child process' PCB. The entry for PTBR is the child's PTBR computed in the previous step. (<b>DO NOT</b> copy values from parent's PCB to child's PCB as it may not be equal to current values) </li>

			<li> The Per-Process Open File table of the parent process is not copied to child's PCB. Instead invalidate all entries in child's Per-Process Open File Table </li>
			<li> Control is passed back to the parent process using <b>ireturn</b>.</b>
		  	</ol>
		  	<b> OS Startup Code</b> is modified to load Interrupt 5 Routine. (The code to load the 2nd process in the previous stage can now be removed).</br>
		  	To test Fork(), use Exec with program to print odd numbers after issuing a Fork from the INIT program (to print even numbers). 


	</br>	</br>
			<h6>Exit</h6>
			<i>System Call No</i>: 10 <br/>
			<i>Interrupt Routine No</i>: 7 <br/>
			<i>Arguments</i>: None<br/>
			<i>Return Value</i>:-1 on failure, exits on success </br>
			This system call is used to terminate the execution of the process which invoked it. Exit removes this process from the memory. If there is only one process, it halts the system.

		</br>	</br>
			<h6>Halt</h6>
			<i>System Call No</i>: 0 <br/>
			<i>Interrupt Routine No</i>: 7 <br/>
			<i>Arguments</i>: None<br/>
			<i>Return Value</i>:-1 on failure, halts on success </br>
			If there is only one process in memory, it halts the system. Otherwise returns -1.
			<br/><br/>
			Both Exit and Halt are implemented in Interrupt 7 Routine. It is to be programmed in SPL, compiled and loaded to the disk using XFS Interface. It does the following tasks 
				<ol>
					<li> If there is only one process, halt the system using <tt>HALT</tt> instruction irrespective of the system call </li>
					<li> If its Exit system call, do the following actions</li>
						<ol style="list-style-type:lower-roman;">
							<li> Find the PCB of the current process using PTBR 
							</li>
							<li> Close all files opened by the process as done for <b>Close</b> system call</li>
							<li> Set the STATE in the PCB to 0.  </li>
							<li> Invalidate all entries in its per-process page table (Set <tt>Address</tt> field to -1) </li>
							<li> Find the next waiting process from the  <a href="xos-spec.html#navpromgmt_readylist">Ready List of PCBs</a></li>
							<li> Get the IP from its PCB and store it in its stack (Compute absolute address of its SP)</li>
							<li> And use <b>ireturn</b> instruction to transfer control.</li>
						</ol>
					<li> Otherwise, exit with -1 </li>	

				</ol>
	 		<b>OS Startup Code</b> is modified to load Interrpt 7 from disk to memory. 
			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>		
			
			<article  id="navstage8" class="grid col-full">
			<h2>Stage 8: Exception Handling </h2>
			<p> 
				<a href="xos-spec.html#navsysroutines_exhandler">Exception Handler</a> in XOS handles exceptions caused by machine. When an exception occurs, the machine sets the <tt>EFR</tt> (Exception Flag Register) and calls the Exception Handler in 
			</p>
			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>		
			
			<article  id="navstage9" class="grid col-full">
			<h2>Stage 9: Making a console </h2>
			<p> 
				The final stage is to make the INIT  process act like a console. INIT written in APL, should be an infinite loop, which takes in  filenames. This filename should correspond to the program to be executed.
				It should <a href="apl-spec.html#navfork"><b>Fork</b></a> itself and <a href="apl-spec.html#navexec"><b>Exec</b></a> using the filename. Appropriate errors must be reported. To have  a time delay between asking for filenames as input, a time-consuming loop may be added  :) 
			 </p>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>		
			
			 <br/><br/>
 			<center><h6>AND THAT'S YOUR OWN </h6><img src="img/logo-img.jpeg" style="margin:0;  width:40px"></center>
			</article>
							
							
			
		</div> <!-- 100%articles-->

		
		</section>	
		
		
		
	</div> <!--main-->
<div class="divide-top">
	<footer class="grid-wrap">
		<ul class="grid col-one-third social">
			<li><a href="http://github.com/XOS-NITC">Github</a></li>
		</ul>
	
		<div class="up grid col-one-third ">
			<a href="#navtop" title="Go back up">&uarr;</a>
		</div>
		
		<nav class="grid col-one-third ">
			<ul><li><a href="index.html" >Home</a></li>
				<li><a href="about.html">About</a></li>
				<li><a href="documentation.html">Documentation</a></li>
				<li><a href="downloads.html">Downloads</a></li>
				<li><a href="roadmap.html">Roadmap</a></li></ul>
			</ul>
		</nav>
	</footer>
</div>
</div>

<!-- Javascript - jQuery 
<script src="http://code.jquery.com/jquery.min.js"></script>-->
<script src="js/jquery-1.7.2.min.js"></script>
<script>window.jQuery || document.write('<script src="js/jquery-1.7.2.min.js"><\/script>')</script>

<!--[if (gte IE 6)&(lte IE 8)]>
<script src="js/selectivizr.js"></script>
<![endif]-->

<script src="js/scripts.js"></script>

<!-- Asynchronous Google Analytics snippet. Change UA-XXXXX-X to be your site's ID. -->
<script>
  var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
</body>
</html>

