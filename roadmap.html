<!DOCTYPE html>

<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->

<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->

<head>
	<meta charset="UTF-8">
	
	<!-- Remove this line if you use the .htaccess -->
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

	<meta name="viewport" content="width=device-width">
	
	<meta name="description" content="Build a simple operating system">
	
	<title>Roadmap // eXperimental Operating System</title>
	<link rel="shortcut icon" type="image/png" href="favicon.png">
	
	<!--<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>-->
	<link rel="stylesheet" href="css/style.css">
	
	<!--[if lt IE 9]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
</head>



<body>
<!-- Prompt IE 7 users to install Chrome Frame -->
<!--[if lt IE 8]><p class=chromeframe>Your browser is <em>ancient!</em> <a href="http://browsehappy.com/">Upgrade to a different browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to experience this site.</p><![endif]-->

<div class="container">

	<header id="navtop">
		<a href="index.html" class="logo fleft">
			<img src="img/logo.png" alt="Designa Studio">
		</a>
		
		<nav class="fright">
			<ul><li><a href="index.html" >Home</a></li>
				<li><a href="about.html">About</a></li>
				<li><a href="documentation.html" >Documentation</a></li>
				<li><a href="downloads.html">Downloads</a></li>
				<li><a href="roadmap.html" class="navactive">Roadmap</a></li></ul>
			</ul>
		</nav>
	</header>


	<div class="services-page main grid-wrap">

		<header class="grid col-full">
			<hr>
			<p class="fleft">Roadmap</p>
		</header>


		<aside class="grid col-one-quarter mq2-col-full">
		
			<menu>
				<ol style="list-style-type:decimal">
					<li><a href="#navstage1" class="sec">Setting up the System</a></li>
					<li><a href="#navstage2" class="sec">Understanding the Filesystem</a></li>
					<li><a href="#navstage3" class="sec">Starting the machine</a></li>
					<li><a href="#navstage4" class="sec">Running a user program</a></li>
					<li><a href="#navstage5" class="sec">Interrupts</a></li>
					<li><a href="#navstage6" class="sec">Multiprogramming</a></li>
					<li><a href="#navstage7" class="sec">Creating Files</a></li>
					<li><a href="#navstage8" class="sec">Playing with Files</a></li>
					<li><a href="#navstage9" class="sec"> Process and Machine System Calls</a></li>
					<li><a href="#navstage10" class="sec">Exception Handling and Demand Paging</a></li>
					<li><a href="#navstage11" class="sec">Making a console</a></li>
				
				</ol>
			</menu>
		</aside>
		
		<section class="grid col-three-quarters mq2-col-full">
		
			
			
			<div class="grid-wrap">











<!---  **************************** STAGE 1 *************************************************** -->







			<article  id="navstage1" class="grid col-full">
			<h2>Stage 1: Setting up the System </h2>

			<p> Follow the instructions in the <a href="usage-spec.html">Usage Documentation</a> to setup the system. This roadmap assumes that the entire package is extracted to $HOME/myxos. If the setting up of the system is done correctly the following directories will be created.
			</p>

			<ul>
				<li><b> $HOME/myxos/apl </b><br/>
				This directory contains the <a href="apl-spec.html">APL</a> (Application Programmers Language) compiler required to compile user programs to XSM machine instructions. Try out APL compiler using the instructions given <a href="usage-spec.html#navapl">here</a>. 
					<ul> 
						<li> $HOME/myxos/apl/samples - Contains sample APL programs for your reference. </li>
						<li> $HOME/myxos/apl/apl_progs - This is an empty directory. The user programs that you write in APL must be saved in this directory.</li>
					</ul>
				</li>
				
				<li><b> $HOME/myxos/spl </b> <br/>
				This directory contains the <a href="spl-spec.html">SPL</a> (System Programmers Language) Compiler required to compile system programs (i.e. operating system routines) to XSM machine instructions. Instructions on how to use SPL compiler is given <a href="usage-spec.html#navspl">here</a>. 
					<ul>
						<li> $HOME/myxos/spl/samples - 	Contains sample SPL programs for your reference.</li>
						<li> $HOME/myxos/spl/spl_progs - This directory is an empty directory. The operating system routines that you code using SPL is to be saved here. </li>
					</ul>
				</li>
				
				<li><b> $HOME/myxos/xfs-interface </b><br/>
				This directory contains an interface through which files from your UNIX machine can be loaded into the File System of XSM (<a href="xfs-spec.html">XFS</a> or Experimental File System). The interface also provides options for formatting the disk, listing the files loaded into the disk, removing files from the disk, copying continuous blocks from the disk to a UNIX file and displaying a file in the XFS disk. Usage instructions and examples can be found <a href="usage-spec.html#navxfs" > here</a>. </li>

				<li><b> $HOME/myxos/xsm </b><br/>
				This directory contains the machine simulator (<a href="xsm-spec.html">XSM</a> or Experimental String Machine). Usage instructions and examples can be found <a href="usage-spec.html#navxsm"> here</a>. </li>

				<li><b> $HOME/myxos/doc </b><br/>
				This directory contains the complete specification for <a href="xos-spec.html">XOS</a> (Experimental Operating System), <a href="xsm-spec.html">XSM</a> (Experimental String Machine), <a href="xfs-spec.html">XFS</a> (Experimental File System), <a href="apl-spec.html">APL</a> (Application Programmers Language) and <a hre="spl-spec.html">SPL</a>(System Programmers Language) and <a href="usage-spec.html">Usage Documentation</a> </li>
			</ul>
			</article>

			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	
			
	










<!---  **************************** STAGE 2 *************************************************** -->

			
			
			<article id="navstage2" class="grid col-full">
				<h2>Stage 2: Understanding the Filesystem </h2>
				 <p><a href="xfs-spec.html">Experimental Filesystem (XFS)</a> is a simulated file system. A UNIX file named "disk.xfs" simulates a hard disk for the machine simulator (XSM). Building XOS begins with understanding the underlying <a href="xfs-spec.html">Filesystem (XFS)</a> and its <a href="usage-spec.html#navxfs">interface</a>. In this stage, you will create an UNIX file and load it to the XFS disk using the XFS-Interface</p>
					<ol>
					<li> Run the XFS Interface
							<div class="syntax">
<pre>cd $HOME/myxos/xfs-interface
./xfs-interface</pre>
							</div> 

						This will take you to the <a href="usage-spec.html#navxfs">xfs-interface</a> prompt. 
					</li>
					<li> Start by formatting the disk in the XFS interface using <b>fdisk</b> command.  Type the following commands in the xfs-interface prompt
						<div class="syntax"> 
<pre># fdisk 
# exit</pre>
						</div>

						You will be back in the UNIX shell and a file named <b>disk.xfs</b> is created in the location <b>$HOME/myxos/xfs-interface/</b>. This UNIX file simulates the hard disk for the machine simulator. The disk is formatted as XFS or Experimental File System. See <a href="xfs-spec.html#navintro"> XFS Specification </a>
					</li>

						<li> Create a file in your UNIX machine with sample data.	<br/>	
							A sample data file is given below
							
<pre>There is a place where the sidewalk ends
And before the street begins,
And there the grass grows soft and white,
And there the sun burns crimson bright,
And there the moon-bird rests from his flight
To cool in the peppermint wind.</pre>
								<br/>
								Save the file as <b>$HOME/myxos/sample.dat</b>
						</li>

						<li> Load this data file ($HOME/myxos/sample.dat) to the XFS disk from your UNIX machine.  This can be done by the following commands
							<div class="syntax"> 
<pre>cd $HOME/myxos/xfs-interface
./xfs-interface
</pre>
							</div>
							This will take you to the xfs-interface prompt. Type the following commands in the xfs-interface prompt.
							<div class="syntax"> 
<pre># load --data $HOME/myxos/sample.dat</pre>
							</div>
						This will load the file to the XFS disk. A FAT entry will be created for this file. <a href="xfs-spec.html#navfat">FAT</a> or File Allocation Table contains information such as the file name, file size and the block number of basic block. The basic block corresponding to a file will contain locations of the file blocks. See <a href="xfs-spec.html#navfile">files</a> in XFS.
						</li>

						<li> Find out the FAT entry corresponding to the loaded file. See <a href="xfs-spec.h
							tml#navdiskorg">disk organization</a> of XFS Disk. Use the <b>copy</b> command to copy FAT entries (FAT is stored in disk block number 10) to a UNIX file (say <i>$HOME/myxos/fat_block.txt</i>).
							<div class="syntax">
<pre># copy 10 10 $HOME/myxos/fat_block.txt
# exit</pre>
							</div>
						</li>	
						<li> Check the <a href="xos-spec.html#navfiles_fat">FAT entry</a> by viewing the <tt>fat_block.txt</tt> file from UNIX machine and find the block number of basic block of the loaded data file. Example of first three lines of <tt>fat_block.txt</tt>  indicating the filename, file size and basic block for this loaded file.
						</li>
						
<pre>sample.dat
512
16</pre>					
						<li>
							Get the basic block number (16 in the above example). Copy the basic block of the file using xfs-interface to a UNIX file (say $HOME/myxos/basic_block.txt) using <b>copy</b> command, to get the data blocks used by this file. Invoke the XFS interface and use the following command.
						<div class ="syntax">
<pre> # copy 16 16 $HOME/myxos/basic_block.txt</pre>
						</div>
						 (<b>NOTE</b>: In this example block number 16 is the basic block of the loaded file)
						 The first few lines of the file <tt>$HOME/myxos/basic_block.txt</tt> is shown below. 
<pre>17
0
0
.
.</pre>						
					This indicates that the only data block of this file is block number 17. Remaining 0 entries, indicates that there are no other data blocks.	</li><br/>	
						
						<li> Copy the data blocks from the XFS disk and display it as a UNIX file <tt>$HOME/myxos/data.txt</tt>. 
						<div class ="syntax">
<pre> # copy 17 17 $HOME/myxos/data.txt</pre>
						</div>		
					We will get back the contents of the file <tt>$HOME/myxos/sample.txt</tt> in <tt>$HOME/myxos/data.txt</tt>. However in <tt>$HOME/myxos/data.txt</tt>, each word is displayed in a line. A  word in XFS is 16 characters long. Sample <tt>data.txt</tt> file is shown below.
<pre>There is a plac
e where the sid
ewalk ends

And before the 
street begins,

And there the g
rass grows soft
 and white,

And there the s
un burns crimso
n bright,

And there the m
oon-bird rests 
from his flight


To cool in the 
peppermint wind</pre>
					</li>				
			</ol>
			</article>










<!---  **************************** STAGE 3 *************************************************** -->

			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	
			

			<article  id="navstage3" class="grid col-full">
				<h2>Stage 3: Starting the machine </h2>

				<p>When the XSM machine is started up, the <a href="xsm-spec.html#navrom"> ROM Code </a> is executed. ROM Code resides in page 0 of the memory. It is hard coded into the machine i.e the ROM code at physical address 0 (to 511) is "already there" when machine starts up. The ROM code is called the "bootstrap" loader in OS literature. ROM code does the following operations :
				<ol>
					<li>Loads block 0 of disk to page 1 of memory (physical address 512).</li>
					<li>After completing 1, sets IP to 512 so that the next instruction to be executed is fetched from location 512 (page 1 in memory starts from location 512).</li>
				</ol></p> 
				<p>So if you write a program in SPL, compile it using SPL compiler and load the compiled code to block 0 of disk using xfs-interface, your  program will be executed by the machine. This program which is loaded to block 0 of disk is supposed to be the <a href="xos-spec.html#navsysroutines_osstartup">OS Startup Code</a>. This OS Startup Code is loaded from disk block 0 to memory page 1 by the ROM Code on machine startup as described above. See <a href="xos-spec.html#navmemorg">Memory Organization</a> and <a href="xfs-spec.html#navdiskorg">Disk Organization</a> </p>

				<p/>The OS designer must design and program  the "OS Startup Code", compile it using the SPL compiler to generate executable program and copy this program to block 0 of the disk (using xfs interface). Once that is done, this code is loaded into page 1 of memory during boot up by the ROM code. Now your program starts executing.</p>
			
				<p>In this stage, we will write a system program to<b> print odd numbers from 1 to n</b> and run it as the OS Startup Code in the machine. The steps to do this are explained in detail below. </p>
				
				<ol>
					<li><p>Create the program to print odd numbers from 1 to n using <a href="spl-spec.html">SPL</a> (System Programmer's Language). See examples of SPL programs in <tt>$HOME/myxos/spl/samples</tt>. <b> It is advised that the system programmer use only the registers R8-R15 while writing SPL programs. </b> </p>
						SPL Code to print odd numbers from 1 to n (taken as input)
						<div class="syntax"> 
<pre>
alias counter R8;
alias n R9;
print "Enter n:";
read n;
counter = 0;
while(counter <= n) do
	if(counter%2 != 0) then
		print counter;
	endif;
	counter = counter + 1;
endwhile; </pre>
						</div>
						<p>
							An SPL program uses the system registers directly instead of variables. For convenience, you can alias the registers with appropriate identifers. See <a href="spl-spec.html#navalias">aliasing</a> in SPL. In the above program R8 is aliased as <i>counter</i> and R9 is aliased as <i>n</i>. The value of <i>n</i> or R9 is taken as input from the user.
						
					</li>
					</p>
					<li>Save this file as <tt>$HOME/myxos/spl/spl_progs/oddnos.spl</tt>. Compile this SPL program using the commands
						<div class="syntax">
						<tt> cd $HOME/myxos/spl </tt><br/>
						<tt> ./spl --os $HOME/myxos/spl/spl_progs/oddnos.spl  </tt> </div> 
					</li> 

					<li> Load the file generated by the SPL compiler ( <tt>$HOME/myxos/spl/spl_progs/os_startup.xsm</tt> ) as the OS startup code to <tt>disk.xfs</tt> using the XFS Interface. Invoke the XFS interface and use the following command to load the OS Startup Code
					<div class="syntax"># load --os $HOME/myxos/spl/spl_progs/os_startup.xsm<br/># exit
					</div>

					</li>

					<li> Run the machine using the command 
						<div class="syntax">
$HOME/myxos/xsm/xsm
						</div>
						<p></p>
					</li>
				</ol>
				The machine will halt after printing all odd numbers from 1 to n
<pre><tt>
Enter n:
10
1
3
5
7
9
Machine is halting
</tt></pre>

				<p> You may also write a few SPL programs on your own and run it on the machine to get familiarized with SPL syntax. Try using the instructions like <a href="spl-spec.html#navbreakpointstmt"><i>breakpoint</i></a> which translates to <a href="xsm-spec.html#navinstr_brkp">BRKP</a> machine instruction. This instruction is useful for debugging. It displays the contents of all the machine registers at the point where the instruction is used.</p>
			</article>

			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	










<!--**************************** STAGE 4 *******************************)-->

			<article  id="navstage4" class="grid col-full">
				<h2>Stage 4: Running a user program </h2>
				<p> User programs or application programs are programmed using <a href="apl-spec.html">APL</a> or Application Programmer's Language. In stage 3, you wrote a system program and executed it. In this stage you will write a user program. </p>
				<p>
					A user program is different from a system program. It is to be noted that a system program is executed in kernel mode ( See <a href="xsm-spec.html#navmodes">Privilege modes</a> ). The machine starts its execution in kernel mode. In kernel mode both privileged and unprivileged <a href="xsm-spec.html#navinstr">instructions</a> can be executed. All memory addresses are physical addresses in kernel mode. A user program should be run in user mode. In user mode only unprivileged instructions can be executed. Also all memory addresses are logical in user mode. In user mode, the machine translates logical addresses to physical addresses using the <a href="xsm-spec.html#navaddr">address translation</a> scheme of the machine. The OS Startup code must load the user program to be executed from the disk to the memory and set up the page tables so that the address translation scheme works correctly. 
				</p>
				<p>
				Before the start of execution of the application program, the mode of execution must be changed from kernel mode to user mode. The value of Instruction Pointer must be set to the starting logical address of the code of the user program (Since all addresses are logical in user mode, program starts executing from logical address 0). Both switching to user mode and setting of the IP is achieved by using <a href="spl-spec.html#naviretstmt"> ireturn</a> instruction. The ireturn instruction in SPL translates to the machine instruction <a href="xsm-spec.html#navinstr_iret">IRET</a>. </p>
				

				<p>In this stage, an application program in APL is compiled and loaded to the disk as the <a href="xos-spec.html#navpromgmt_init">INIT</a> program. The first user program which is executed is called the INIT program. INIT program is stored in blocks 13-15 of the XFS disk. It does not have a FAT entry or a basic block. An OS Startup code is written in <a href="spl-spec.html">SPL</a> to load the INIT program to the memory on OS startup.</p>

				<ol>
					<li> Write a program in APL to print all prime numbers lesser than a number taken as input. See <a href="apl-spec.html#navexamples">Examples</a> of APL programs. In the roadmap, the path of the file is assumed to be <tt>$HOME/myxos/apl/apl_progs/prime.apl</tt>. This program will be the INIT program in this stage. </li><br/>
					<li> Compile your APL program using the command
						<div class="syntax">
							<tt> cd $HOME/myxos/apl </tt><br/>
							<tt> ./apl $HOME/myxos/apl/apl_progs/prime.apl  </tt>
						</div> 
						The output file generated is $HOME/myxos/apl/apl_progs/prime.xsm
					</li>
					<br/>
					<li> Load this file to <b>disk.xfs</b> as <b>INIT program</b> using XFS interface.
					<div class="syntax">
						# load --init $HOME/myxos/apl/apl_progs/prime.xsm
					</div></li>
					<li> When the program finishes execution of the user program, the machine must halt. To do this, create an SPL program with just a <b>halt;</b> instruction. Here, we have assumed its path to be <b>$HOME/myxos/spl/spl_progs/haltprog.spl</b>.  </li> 

					Compile this program using --int=7 flag as shown. 
					<div class="syntax">
						cd $HOME/myxos/spl <br/>
						./spl --int=7  $HOME/myxos/spl/spl_progs/haltprog.spl <br/>
					</div>
					Now a file  named <tt>int7.xsm</tt> is created in <tt>$HOME/myxos/spl/spl_progs/</tt>. <br/><br/>
					Load this file to the XFS Disk (disk.xfs) using XFS interface as Interrupt routine 7.
					<div class="syntax"># load --int=7 $HOME/myxos/spl/spl_progs/int7.xsm</div>
					Interrupt routine 7 is  responsible for halting the machine upon completion of running user program. Interrupt routine 7 is invoked at the end of every user program. APL compiler adds the <tt>INT 7</tt> instruction at the end of every compiled application program. This is to be loaded into the memory by the OS Startup Code.  You will learn about <a href="xos-spec.html#navsysroutines_interrupt">interrupts</a> in later stages.
					</li><br/><br/>
					<li> In this stage, it must be ensured that the machine will terminate on <a href="xsm-spec.html#navexcep">exceptions</a>. Upon encountering an exception, the machine invokes an <a href="xos-spec.html#navsysroutines_exhandler">exception handler</a> routine. In this stage, simply halt on exceptions. Compile the SPL program used in the previous step (<tt>HOME/myxos/spl/spl_progs/haltprog.spl</tt>) using <tt>--exhandler</tt> flag 
					<div class="syntax">
						cd $HOME/myxos/spl <br/>
						./spl --exhandler $HOME/myxos/spl/spl_progs/haltprog.spl <br/>
					</div>						
					Now a file  named <tt>exhandler.xsm</tt> is created in <tt>$HOME/myxos/spl/spl_progs/</tt>. <br/><br/>
					Load this file to the XFS Disk (disk.xfs) using XFS interface as Exception Handler
					<div class="syntax"># load --exhandler $HOME/myxos/spl/spl_progs/exhandler.xsm</div>.
					 This is to be loaded into the memory by the OS Startup Code. You will learn in detail about <a href="xos-spec.html#navsysroutines_exhandler">exception handler</a> in later stages.
				</ol>

				<h6>OS Startup Code</h6>
				<ol>
					Interrupt Routine 7, Exception Handler routine and the program to print primes must be loaded from the XFS disk to the memory  by the OS Startup Code when the OS starts. The OS Startup Code must be written in <a href="spl-spec.html">SPL</a>, compiled and loaded to the disk as done in stage 3. The new OS Startup Code must do the following tasks. </br><br/>

					<li> Load Exception Handler from disk block 1 to memory page 7 and Interrupt Routine 7 from disk block 9 to memory page 15 using <a href="spl-spec.html#navlsstmt" >load</a> instruction. See <a href="xos-spec.html#navmemorg">Memory Organization</a> and <a href="xfs-spec.html#navdiskorg">Disk Organization </a>
						<div class="syntax">
							load (page_number, block_number);
						</div> 
					</li>

					<li><p>The program to print primes will be loaded as the INIT program. Since the INIT program is the first user program that is executed, it should be assigned a PID (Process Identifier) value 0.</p>

					<p>
					The first structure to setup is the INIT's Process Control Block. ( See <a href="xos-spec.html#navpromgmt_pcb">PCB</a> ). The <a href="xos-spec.html#navpromgmt_readylist">Ready List of PCBs</a> starts from memory address 1536. In general, the starting address of the PCB of a process is computed using the formula <pre>1536 + (PID x 32)</pre>
					Each PCB is of size 32 words. Hence, PID x 32 will be the index into the Ready List of PCBs. PID of INIT process is 0, and hence its PCB's starting address is 1536. While writing SPL programs, you may use the <a href="spl-spec.html#navconst">predefined constant</a> <tt>READY_LIST</tt> instead of this value.
					The first word in the PCB stores the PID of the corresponding process. Set the 1st word of the PCB with the value 0 (which is the PID for INIT Process)
							<div class="syntax">
								[READY_LIST + 0] = 0 // Sets the entry for PID as 0
							</div>	
					<li>Load the <b>INIT program</b> (program to print primes) from the disk to the memory. In the memory, user programs are stored in pages 16-63. Since INIT is the first process, we will allocate the first 3 pages (pages 16-18) for code. Every running process will require a stack. Memory page 19 can be allocated for the stack.  See <a href="xos-spec.html#promgmt_prostruct">Process Structure</a>. The blocks 13-15 from disk is to be loaded to the memory pages 16-18.  See <a href="xos-spec.html#navmemorg">Memory Organization</a> and <a href="xfs-spec.html#navdiskorg">Disk Organization </a></li>
							<div class="syntax">
								load(16,13);<br/>
								load(17,14);<br/>
								load(18,15);<br/>
							</div>
					<li> Page Tables for INIT must be setup for address translation scheme to work correctly. See <a href="xsm-spec.html#navaddr">Address Translation</a>. The starting address of process page tables is 1024 (See <a href="xos-spec.html#navmemorg" >Memory Organization</a>). The PTBR or Page Table Base Register stores the starting address of the page table of a process. PTBR of a process is calculated using the formula <pre> 1024 + (PID x 8) </pre>

						 Since PID of INIT is 0, PTBR value of INIT is set as 1024. 
						 <div class="syntax">PTBR = 1024; </div>

						 <b>PTLR</b> (Page Table Length Register) stores the number of entries in the page table of a process. In XOS the page table of every process will have 4 entries. So, PTLR is set as 4.<br/>
						 <div class="syntax">PTLR = 4; </div>
						 Every process consists of 4 pages - 3 pages for code and 1 for stack (See <a href="xos-spec.html#navpromgmt_prostruct">Process Structure</a>). </li><br/>

					 <p>Each page table entry contains 2 words. See <a href="xos-spec.html#navmemmgmt_paging">Paging</a> for the structure of page table entry. The first word of each entry indicates the physical page number corresponding to a logical page number. The logical page number is the index of the page table entry. The 2nd word of each entry contains the auxiliary information, which will be used for Virtual Memory Management in latter stages. </p>

								 Setup entries for memory pages 16 to 18 (3 pages are used for code)  as well as one entry for memory page 19 (1 page is used for stack) in the page table. Set the first word of each entry to corresponding physical page number (16 to 19) and set the second word (Auxiliary information) as <b>11</b> (Valid and Referenced).</li><br/>
							Setting up the entries of page table can be done in the following way
							<div class="syntax">
								[PTBR + 0] = 16;  // 1st Word of Page Table Entry 1 - Page Number<br/>
								[PTBR + 1] = 11;  // 2nd Word of Page Table Entry 1 - Auxiliary Information<br/>
								.	<br/>
								.	<br/>
								.	<br/>
								[PTBR + 6] = 19;  // 1st Word of Page Table Entry 4 - Page Number of stack <br/>
								[PTBR + 7] = 11;  // 2nd Word of Page Table Entry 4 - Auxiliary Information<br/>
							</div>
						
					</li>					
					
					<li> Once  all structures are setup we can set <tt>STATE</tt> field in the PCB of INIT process is set to 2 (running). <div class="syntax">
								[READY_LIST + 1] = 2; // Sets the entry for STATE as 2 (Running)
							</div> The remaining entries of the PCB need not be set by the OS startup code. You will learn about these in subsequent stages.  
							
					</li> <br/>
					

					<li> 
						<p> Next we need to set the stack pointer (<b>SP</b>) register. Each program in memory has an associated runtime stack. A runtime stack holds the local variables and function parameters while a process is running. The Stack Pointer or <b>SP</b> points to the top of this stack.</p>

						<p>The stack of every process in XOS starts at logical address 3 x 512 (= 1536) which corresponds to logical page number 3 ( page numbering of a process starts from 0). It grows in till logical address 4 x 512 - 1 (= 2047). </p>

						<p> Before OS Startup Code transfers control to the user program, the value of <b>SP</b> must be set to its starting logical address ( 3 * 512 = 1536). Every user program runs in user mode. In user mode, all addresses are logical addresses. Since SP is used by the user program, its address should be a logical address. </p>

						<div class="syntax">SP = 3 * 512; </div>
						
						
				
					</li>
					<li>
						<p> The OS Startup Code transfers control of execution to the user program using an <a href="xsm-spec.html#navinstr_iret"><tt>IRET</tt></a> instruction. An IRET performs the following operations implicitly 
							<ol style="list-style-type:lower-roman">
								<li> The privilege mode is changed from KERNEL to USER mode. </li>
								<li> The value in the top of the user stack (pointed to by SP) is stored in IP or Instruction Pointer. The IP register points to the address of the next instruction to be executed. This value cannot be changed explicitly by the programmer using any other instruction. </li>
								<li> Decrement the value of SP by 1 </li>
							</ol>
						<p> For an <tt>IRET</tt> instruction to function properly, the value at the top of the stack should be the address of the next instruction. This value gets stored in IP.</p>

						<p> The code pages of every program in memory starts from logical address 0. Hence <b>IP</b> or instruction pointer needs to be set to 0. As IP cannot be set explicitly, put the value 0 to the top of the stack, and <tt>IRET</tt> instruction will implicitly set the IP to this value. Since we are currently in KERNEL mode, the top of the stack is identified using its physical address. Stack of INIT process is allocated physical page number 19. Its corresponding physical address is 19 * 512. Use the following instruction to put 0 in the top of the stack. 

						<div class="syntax">
							[19*512] = 0;
						</div>
					See <a href="xsm-spec.html#navmodes">privilege modes</a> and <a href="xsm-spec.html#navaddr">address translation</a> for detailed information. 
					</li>	
					<br/>

					<li> Use the <b>ireturn</b> instruction to transfer control to user program. <b>ireturn</b> translates to <tt>IRET</tt> machine instruction  </li> 
					<div class="syntax">
						ireturn;
					</div>
				</ol>
			<h6>Making things work !</h6><br/>
			<p> You have already written, compiled and loaded your user program to <b>disk.xfs</b>. You have also loaded Interrupt routine 7 and Exception Handler to <b>disk.xfs</b>. </p>
			<p> After finishing writing OS Startup Code in SPL, save it as <b>$HOME/myxos/spl/spl_progs/os_startup.spl</b>. You should compile this file using SPL compiler with --os flag as shown.</p>
			<div class="syntax"><pre> cd $HOME/myxos/spl
./spl --os $HOME/myxos/spl/spl_progs/os_startup.spl</pre>
			</div>
			<p>This will generate a file <b>$HOME/myxos/spl/spl_progs/os_startup.xsm</b>.	Load this file as the OS startup code to <tt>disk.xfs</tt> using the XFS Interface. Invoke the XFS interface and use the following command to load the OS Startup Code. </p>
					<div class="syntax"># load --os $HOME/myxos/spl/spl_progs/os_startup.xsm<br/># exit
					</div>
			<p> Run the machine by disabling the timer. The machine has a timer which interrupts the execution at specific intervals while running a user program. It passes the control to timer interrupt routine. We will be dealing with the timer in stage 5 (Interrupts). Until then we will run the machine with the timer disabled.  The <i>--timer=0</i> flag is used to disable the timer. </p>
			<div class="syntax">$HOME/myxos/xsm/xsm --timer=0<br/></div>
			If the timer is not disabled, the machine will get stuck when a timer interrupt occurs. This is because the control has passed to the Timer Interrupt Routine which is not  loaded into the memory. 
			<br/><br/>
			The output will be similar to the one given below,
			<pre>Enter n:
10
2
3
5
7
Machine is halting</pre>
			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>










<!-- ************************ STAGE 5***************** ************************** !-->

			<article  id="navstage5" class="grid col-full">
			<h2>Stage 5: Interrupt Routines </h2>
			<p> When an interrupt occurs while the XSM simulator is running, it transfers control to specific memory locations corresponding to the interrupt. Interrupts can be invoked either by hardware or software through instructions. In XSM, the only hardware interrupt is timer interrupt, which is triggered in fixed intervals of intstructions. However in general, a timer interrupt is triggered in fixed intervals of time. There are 6 software interrupts in XSM, invoked using machine instrutions <tt>INT 1</tt> to <tt>INT 7</tt>. </p>
			<p>Interrupts can only be triggered or invoked in user mode. In Kernel mode interrupts are disabled. Upon encountering an interrupt, the machine transfers control to specific locations in memory and changes from user mode to kernel mode. These locations in memory contains Interrupt Routines. (See <a href="xos-spec.html#navmemorg">Memory Organization</a>). Interrupt routines is a set of privileged instructions which provides kernel level services to user programs. Memory page 8 contains the Timer Interrupt Routine which is invoked after specific intervals of instructions. Memory page 9 to 15 contain Interrupt Routine 1 to 7, invoked using <tt>INT 1</tt> to <tt>INT 7</tt> machine instructions respectively. The interrupt instructions <tt>INT 1</tt> to <tt>INT 7</tt> can be invoked from an application program using system call interfaces. You will be implementing system calls in the subsequent stages. In this stage you'll be implementing a sample timer interrupt and a software interrupt. See <a href ="xsm-spec.html#navintrrupt">Interrupts</a> for more details.
			</p>
			
			<h5>Implementing Software Interrupt</h5>
			<p> Upon encountering the <b>INT</b> machine instruction in a user program, the OS transfers control to the corresponding interrupt routine. The interrupt routines reside in pages 9 to 15 of the memory (See <a href="xos-spec.html#navmemorg">Memory Organization</a>). </p>
			<p>

			In this stage you'll do a test implementation of  interrupt routine 1. Your task is to display <tt>"SW Interrupt"</tt> when <b>INT 1</b> instruction is encountered. To do this, you will need to create Interrupt Routine 1 system program to display the message <tt>"SW Interrupt"</tt>. This program must be loaded to memory by the OS Startup Code. Now, when invoking an <tt>INT 1</tt> instruction in a user program, the machine transfers control to Interrupt Routine 1. Interrupt Routine 1 prints <tt>SW Interrupt</tt> on the screen and transfers control back to the user program.  Follow these steps to get this done,</p>

			<ol>
				<li> <p>Create an SPL program to print <tt>SW Interrupt</tt>. Use an <tt>ireturn;</tt> instruction in the end. The sample SPL program is given below</p>
					<div class="syntax">
					print "SW Interrupt";<br/>
					ireturn; </div>
				<p>
				This machine code corresponding to this program is the Interrupt 1 routine. This program will be executed when a user program invokes the <tt>INT 1</tt> instruction. After printing <tt>SW Interrupt</tt> the <tt>ireturn;</tt> instruction is executed. The <tt>ireturn</tt> instruction is responsible for transferring the control back to the user program which invoked the <tt>INT 1</tt> instruction.
				</li></p>
				
				<li> Save this file in your UNIX machine as <b>$HOME/myxos/spl/spl_progs/sample_int.spl</b> </li>
				<li> Compile this program using SPL compiler with the flag <tt>--int=1</tt>. This flag is used because this program is to be loaded as the Interrupt 1 routine. 
				
					<div class="syntax">
						cd $HOME/myxos/spl<br/>
						./spl --int=1 $HOME/myxos/spl/spl_progs/sample_int.spl
					</div>
				 <p>The output file generated will be <b>$HOME/myxos/spl/spl_progs/int1.xsm</b></li>
				 </p>
				<li> Load this file to the XFS disk as interrupt 1 using xfs-interface. </li>
					<div class="syntax">
						# load --int=1 $HOME/myxos/spl/spl_progs/int1.xsm <br/>
						# exit
					</div>				
				
				<li> Create a user program to invoke INT 1. For simplicity, write the program using XSM Machine instructions directly instead of APL. This program prints <tt>Before INT</tt>, invokes Interrupt Routine 1 using <tt>INT 1</tt> instruction, and then prints <tt>After INT</tt>. The <tt>INT 7</tt> instruction before the <tt>END</tt> instruction is used to halt the machine after executing the user program. You've previously implemented the Interrupt Routine 7 with <tt>HALT</tt> instruction.
					<div class="syntax">
						START <br/>
						MOV R0, "Before INT" <br/>
						OUT R0 <br/>
						INT 1 <br/>
						MOV R0, "After INT" <br/>
						OUT R0<br/>
						INT 7 <br />
						END
					</div>
				</li>
				<li> Load it directly to the XFS disk as <a href="xfs-spec.html#navinit">init program</a>. This program is already in XSM machine code, and hence it need not be compiled.
				</li>
				<li> Modify the OS Startup Code to load the <b>Interrupt 1 Routine</b> from disk block 3 (See <a href="xfs-spec.html#navdiskorg">Disk Organization</a>) to memory page 9 (See <a href="xos-spec.html#navmemorg">Memory Organization</a>). Add the following line to OS startup code before the <tt>ireturn;</tt> instruction.
					<div class="syntax">load (9, 3);</div>
				</li>
				<li> Compile the OS Startup Code using SPL compiler. 
				<div class="syntax"><pre>cd $HOME/myxos/spl
./spl --os $HOME/myxos/spl/spl_progs/os_startup.spl</pre></div>
				
				<li> Load the compiled output file $HOME/myxos/spl/spl_progs/os_startup.xsm to the XFS disk using XFS interface</li>
				<li> Run the machine by disabling the timer.
					<div class="syntax"> $HOME/myxos/xsm/xsm --timer=0 </div>
					You'll get the following output on the screen.
<pre><tt>
Before INT
SW Interrupt
After INT
Machine is halting
</tt></pre>
				</li>
			</ol>			
			
			<br/>
			<h5>Implementing Timer Interrupt</h5>
			<p> The XSM simulator has a timer which invokes the timer interrupt routine after specific number of instructions. The Timer Interrupt Routine resides in Page Number 8 (See <a href="xos-spec.html#navmemorg">Memory Organization</a>) of the memory. Refer <a href="xsm-spec.html#navtimer">Timer Interrupt</a>.
			</p>
			<p>Your task is to display <tt>TIMER</tt> when a timer interrupt is triggered. Create a timer interrupt routine, which prints "<tt>TIMER</tt>". The Timer Interrupt Routine is loaded to memory by the OS Startup Code. The sample program to print numbers up to 20 is compiled using APL compiler and used as INIT program. The Machine is run without disabling the timer. After fixed number of instructions in the user program are executed, the timer interrupt occurs and control is passed to the timer interrupt routine. This routine prints <tt>TIMER</tt> and returns to the user program. Timer Interrupt occurs after fixed intervals of instruction. The interval can be specified while the machine is run. Default interval for timer interrupt is 10 instructions. 
			</p>
			<p>
			Detailed instructions to get this done are given below.</p>

			<ol>
				<li> Create an SPL program to print "TIMER". The sample SPL program is given below
					<div class="syntax">
						print "TIMER";<br/>
						ireturn;
					</div>
				</li>
				<li> Save this file in your UNIX machine as <b>$HOME/myxos/spl/spl_progs/sample_timer.spl</b> </li>
				<li> Compile this program using SPL compiler with the flag --int=timer.
					<div class="syntax">
						cd $HOME/myxos/spl<br/>
						./spl --int=timer $HOME/myxos/spl/spl_progs/sample_timer.spl 
					</div>
				<p>The output file generated will be in <b>$HOME/myxos/spl/spl_progs/timer.xsm</b> 
				</li></p>
				
				<li> Load this file to XFS disk as Timer Interrupt Routine using XFS Interface.</li>
				<li> Compile the sample program to print numbers upto 20 using APL compiler. The sample program is available at <b>$HOME/myxos/apl/samples/printnum.apl</b>. Load the compiled output as the INIT program to XFS disk.  </li>
				
				<li> Modify the OS Startup Code to load the <b>Timer Interrupt Routine</b> from disk block 2(See <a href="xfs-spec.html#navdiskorg">Disk Organization</a>) to memory page 8 (See <a href="xos-spec.html#navmemorg">Memory Organization</a>).  Add the following line to OS startup code before the <tt>ireturn;</tt> instruction.
				<div class="syntax">load (8, 2);</div>
				</li>
				<li> Compile the new OS Startup Code using SPL Compiler, and load it to the XFS disk using XFS Interface.</li>
				<li> <p>Now, run the machine <b>without</b> disabling the timer, to see the timer interrupt routine in action. To enable the timer, omit the &nbsp; &nbsp; &nbsp; <tt>--timer</tt> flag. You can specify the interval of instructions after which the timer interrupt is triggered by specifying a <tt>value</tt> in the <tt>--timer=&lt;value&gt;</value></tt>. The default <tt>value</tt> is 10 instructions.</p>
				
					<div class="syntax">$HOME/myxos/xsm/xsm </div>
					You'll get the following output on the screen
<pre><tt>1
2
TIMER
3
4
5
6
7
TIMER
8
9
10
11
12
TIMER
13
14
15
16
17
TIMER
18
19
20
Machine is halting
</tt></pre>
				</li>
			</ol>
			</article>

			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	


			<article  id="navstage6" class="grid col-full">
			<h2>Stage 6: Getting started with Multiprogramming</h2>
			<p> <a href="xos-spec.html#navpromgmt_multiprog">Multiprogramming</a> refers to running more than one process simultaneously. In XSM, the timer interrupt is triggered after a fixed number of instructions are executed in user mode, and the control is passed to Page 8, i.e. the timer interrupt routine. In the previous stage you made the timer interrupt to display <tt>TIMER</tt> at fixed intervals. The actual function of timer interrupt routine is to schedule processes in memory and execute them. </p>
			
			<p>The timer interrupt routine should save the context of the current process in its Process Control Block ( <a href="xos-spec.html#navpromgmt_pcb">PCB</a> ), schedule and dispatch a new process to be run on the machine. In this stage we run two programs simultaneously in an interleaved manner on the machine. The machine is run without disabling the timer. <br/>
			</p>

			<p>OS Startup Code must be modified to load two programs into the memory and start the execution of one program. The timer interrupt routine when invoked, saves the context of current running process and starts the execution of the other process. 'Saving the context' means storing back the values of registers into fthe PCB of the currently running process. </p>
			
			<p>Detailed instructions to implement multiprogramming is given below.</p>
			 <h6>Creating User Programs</h6>
					<ol>
						<li> Write an APL program to print all odd numbers from 1 to 20 and save it as <b>$HOME/myxos/apl/apl_progs/odd.apl</b> </li>
						<li> Compile this program using APL compiler and load the <b>$HOME/myxos/apl/apl_progs/odd.xsm</b> file generated to the disk using XFS Interface as init program. </li>
						<li> Write another APL program to print all even numbers from 1 to 20 and save it as <b>$HOME/myxos/apl/apl_progs/even.apl</b> </li>
						<li> Compile this program using APL compiler and load the <b>$HOME/myxos/apl/apl_progs/even.xsm</b> file generated to the disk using XFS Interface as an executable file. </li>
						<div class="syntax"># load --exec $HOME/myxos/apl/apl_progs/even.xsm </div>
						<li> Use the XFS interface to find the data blocks to which this file is loaded as done in Stage 2. In this roadmap, we assume that this file is loaded to blocks 16 - 19. The basic block of the file is in block 16 and the data blocks are in blocks 17, 18 and 19. Note that this may not be the actual scenario. </li>
					</ol>
			<br/>
			
			<h6>Modify the OS Startup Code</h6> <br/>
					<p>The previous OS startup code loads only the INIT process and sets its process structures only. In this stage, the OS Startup Code has to be modified to load the second process and set up PCB and page table of this process also. But for the subsequent stages, the previous OS Startup code is enough. So before modifying the OS Startup Code, take a backup copy of it so that it can be used for the subsequent stages.
					</p>
					<p>Before the <tt>ireturn</tt> statement in the OS Startup Code, it should load and set up the process structures for the second process.</p>
					<ol>
						<li><p>The PID (Process Identifier) for the second process will be 1. This is because, the INIT process has been assigned PID.</p>
						<p>PID field in the PCB of the second process is set to 1. The starting address of PCB for any running process is calculated using the formula discussed in Stage 4. </p>
						<p>1536 + (PID x 32) </tt></p>
						The value 1536 is stored in the the predefined SPL constant <tt>READY_LIST</tt>.
							<div class="syntax">
								[READY_LIST + 32] = 1; 		// Sets the entry for PID as 1<br/>
							</div>
						</li>
						<li> Load the code blocks of the second program from disk (We have assumed that the code blocks are stored in blocks 17 - 19 in the disk) to pages 20 - 22 in memory. Pages 16 to 19 have already been allocated for the INIT process. So the second, process can be allocated pages after 19. For convenience we have used pages 20 to 22 in the memory. (See <a href="xos-spec.html#navmemorg">Memory Organization</a>)
							<div class="syntax">
								load(20,17);<br/>
								load(21,18);<br/>
								load(22,19);<br/>
							</div>
						</li>
						<li><p>Page Table for this process must be setup. The starting address of the page table of a process is calculated using the formula discussed in stage 4. </p>
						<tt>1024 + PID * 8</tt>
						<p><br/>
						The register R8 is aliased as <tt>PTBR_Process1</tt> and assigned this value as shown below. See <a href="spl-spec,html#navalias">Aliasing</a> in SPL Specification.</p> 
						<div class="syntax">
						alias PTBR_Process1 R8;<br/>	
						PTBR_Process1 = 1024 + 1 * 8;
						</div>
						</li>
						<li><p>Setup page table entries for memory pages 20 to 22 (3 pages are used for code) as well as one entry for memory page 23 (1 page is used for stack) as shown below. First word of each entry	is the physical page number and the 2nd word is the auxiliary information.

	<div class="syntax">
								[PTBR_Process1 + 0] = 20;  // 1st Word of Page Table Entry 1 - Page Number<br/>
								[PTBR_Process1 + 1] = 11;  // 2nd Word of Page Table Entry 1 - Auxiliary Information<br/>
								.	<br/>
								.	<br/>
								.	<br/>
								[PTBR_Process1 + 6] = 23;  // 1st Word of Page Table Entry 4 - Page Number of stack <br/>
								[PTBR_Process1 + 7] = 11;  // 2nd Word of Page Table Entry 4 - Auxiliary Information<br/>
							</div>						

						  </p></li>
						
						<li> For the second process all the entries in the <a href="xos-spec.html#navpromgmt_pcb">PCB</a> must be setup. This is because the timer interrupt routine loads the context of this process from its <a href="xos-spec.html#navpromgmt_pcb">PCB</a>. The context of the process refers to  all the registers and open files associated with a process.
							<ul>
								<li>STATE field is set to 1 (ready)
								<div class="syntax">
								[READY_LIST + 33] = 1;		// Sets the entry for STATE as 1 (Ready)
								</div></li>
								<li>PTBR field of the PCB is set to <tt>PTBR_Process1</tt>. PTLR field is set to 4 since the maximum number of entries in a page table of the process is 4. 
								<div class="syntax">
								[READY_LIST + 37] = PTBR_Process1;	// PTBR <br/>
								[READY_LIST + 38] = 4;		// PTLR
								</div></li>								
								<li> SP and BP fields in the PCB are set to the starting logical address of the process stack. The stack of any process starts at logical page number 3, which corresponds to logical address 3 * 512.
								<div class="syntax">
								[READY_LIST + 34] = 3 * 512; 	// Sets the entry for BP in the PCB<br/>
								[READY_LIST + 35] = 3 * 512;	// Sets the entry for SP in the PCB
								</div>								
								</li>
								<li> Code area of the process starts from logical address 0, so IP field is set to zero. 
								<div class="syntax">
								[READY_LIST + 36] = 0;		// Sets the entry for IP in the PCB
								</div>								
								</li>
							The rest of the entries of the PCB may not be set now. You will deal with them in subsequent stages.
							</ul>
						</li> <br/>
						<li> Add the instruction to load the timer interrupt routine from disk block 2 to memory page 8. See <a href="xos-spec.html#navmemorg">Memory Organization</a> and <a href="xfs-spec.html#navdiskorg">Disk Organization </a>. 
							<div class="syntax">
								load(8,2);
							</div>
						</li>
					
					</ol>
				</li>
				<br/>
			
				<h6>Timer Interrupt Routine</h6> <br/>
				Next task to be done in this stage, is to program the Timer Interrupt in SPL, compile it and load it to the disk.  <br/>
					The timer interrupt routine must perform the following actions:
					<ol>
						<li> Find the PID or Process Identifier of the currently running process. In XOS, PID is calculated from the value of the <tt>PTBR</tt> using the formula <b><tt> (PTBR - 1024) / 8</tt></b>. The Per-Process Page tables are stored in memory from address 1024 onwards. Each page table is of size 8 words. The PTBR value gives the starting address of the current process' page table. Hence this calculation will give the Process ID for the currently running process. Note that this calculation is specific to XOS. In general Process ID cannot be computed  from the value of PTBR . <div class="syntax"><pre>alias currentPID R8;
currentPID = (PTBR - 1024) / 8;</pre>
						</div> </li>		
										
						<li><p>Find the location of the  <a href="xos-spec.html#navpromgmt_pcb">PCB</a> of the current process using the formula 1536 + 32 * currentPID, as discussed previously</li>
						<div class="syntax"><pre>alias currentPCB R9;
currentPCB = READY_LIST + 32 * currentPID;</pre>
						</div> </li>	
						</p>
					
						<li>The Timer Interrupt Routine must store back the current registers to the PCB of the current process. It can then assign the registers with the values corresponding to the next scheduled process.
						 <ul>
							<li> Set BP and SP entry in the PCB with values in registers <tt>BP</tt> and <tt>SP - 1</tt>. When an interrupt occurs, the value of IP is stored automatically on the top of the stack and SP is incremented. Hence SP - 1 is the correct value of SP of this process ignoring the <tt>IP</tt> pushed by the interrupt at the top of the stack.
							<div class="syntax">
								[ currentPCB  + 2 ] = BP;<br/>
								[ currentPCB  + 3 ] = SP - 1;	<br/>
							</div>							
							</li>
							<li> <p>Next, you need to set the IP field in the PCB. When a timer interrupt occurs, the IP value gets stored in the user stack. The timer interrupt routine should fetch this value from the stack and store it in the IP field of the PCB. But the timer interrupt routine is in KERNEL mode and <tt>SP</tt> contains the logical address of the top of the user stack. You will need to find the physical address of the stack pointer </p> 
							<p>
							Physical page number corresponding to a logical address is obtained from the page table.  <tt><i>logical address / 512</i></tt> gives the logical page number. Multiplying this by 2 gives the index of the page table entry. Adding PTBR to this will give the physical address of the page table entry corresponding to the given logical address.  <b><pre>Address of page table entry = PTBR + 2 x (<i>Logical Address</i> / 512) </pre></b>The value stored in the first word in the page table entry corresponds to the physical page number. </p>
							<b><pre>Physical Page Number = [ Address of page table entry + 0 ] </pre></b>
							<p> Offset into the page is calculated as </p>
							<pre><b>offset = logical_address % 512</b></pre> 
							<p> The physical address is computed by multiplying the physical page number by page size (=512) and adding the offest. </p>
							<pre><b>Physical Address = Physical Page Number x 512 + offset </pre></b></p>
							<p> <b>NOTE</b>: In user mode, logical addresses are translated to physical address by the machine using its address translation scheme. However, in kernel mode, you will need to manually translate any logical address to physical address using the procedure given above.</p>
							
							<p> For calculating the physical address of SP, use the following instructions
			<div class="syntax">alias physicalSP R10;</br>
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
						</div>							
							</p>
							
							Now, get the value of IP from the top of the stack and store it in the IP field of  PCB. This can be done using the following instructions.
		<div class="syntax">[ currentPCB + 4 ] = [ physicalSP ]; </div>
							</li>
							<li>Set PTBR and PTLR fields of the PCB with the values in <tt>PTBR</tt> and <tt>PTLR</tt>
							<div class="syntax">
								[ currentPCB  + 5 ] = PTBR;<br/>
								[ currentPCB  + 6 ] = PTLR	;	<br/>
							</div>									
							</li>
							<li>Set PCB fields for registers R0 to R7 with values in <tt>R0</tt> to <tt>R7</tt>
							<div class="syntax">
								[ currentPCB + 7 ] = R0;	<br/>
								.<br/>
								.<br/>
								[ currentPCB + 14 ] = R7;<br/>
							</div>									
							</li>							
						 </ul>
						</li>
						<li> Now, the next process to be scheduled for execution is to be selected. To do this, scan the <a href="xos-spec.html#navpromgmt_readylist">Ready List of PCBs</a> in a circular manner starting from the PCB of current process to check for the next process with STATE value 1 (Ready) in its PCB. Store the address of the newly found process' PCB  in a register. In this roadmap we have assumed this register's alias to be <tt>newPCB</tt>.</li>
						<li> Load the fields except IP from this PCB to the corresponding registers . This is because IP value cannot be explicitly changed or set.  </li>
						<li><p> IP value is set by the <b>ireturn;</b> instruction as explained in Stage 4. For this to work correctly, we need to fetch the value from the IP field in the PCB and store it in the top of the stack. <tt>ireturn</tt> will take this value from the stack and store it in the IP register. 
						</p>
						<p> When a value is stored on the top of the stack, SP needs to be incremented by 1 </p>
						<div class="syntax"> SP = SP + 1; </div>
						<li><p>
						To store the value on top of the stack, we will need to calculate physical address of SP for the new process as desicribed in Step 3. We have assumed that this new physical SP is aliased as <tt>newphysicalSP</tt>.</li>
						<li> Store IP from this PCB to the location pointed by the <tt>newphysicalSP</tt>.  Since we are pushing a value onto the stack, we need to increment SP by 1.</li></p>
						<div class="syntax">
							[ newphysicalSP ] = [ newPCB + 4 ]; // Stores IP field value of PCB on the stack <br/>
							
						</div>
						<li> Set the STATE field of the current PCB to 1 (Ready) and the new PCB to 2 (Running). Now the new process is schedule for execution and set as Running. The previously running process in now in Ready State, i.e. it is waiting for the CPU.</li>
						<li> Use <b>ireturn</b> instruction to return to USER Mode </li>
					</ul>
				</li>
			</ol>
			<h6> Making things work!</h6>
			<ol>
				<li> Compile the OS Startup Code and Timer interrupt Routine using the SPL Compiler.  </li>
				<li> Load the compiled output .xsm files corresponding to  OS Startup code and timer interrupt routine to the XFS disk using XFS interface. </li>
				<li> Run the machine without disabling timer </li>
				<div class="syntax">$HOME/myxos/xsm/xsm</div>
				
			</ol>
			The output will have odd and even numbers printed in an interleaved fashion. This indicates that both programs, i.e. program to print odd numbers and the program to print even numbers ran simultaneously on the machine, and your timer interrupt switched between processes after fixed intervals. 

			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>










<!---  **************************** STAGE 7 *************************************************** -->


			<article id="navstage7" class="grid col-full">
				<h2>Stage 7: Creating Files </h2>
		
				<p> In this stage, you'll learn to implement a <a href="xos-spec.html#navsyscalls"> system call </a>. System calls are interfaces provided by the operating system to the user programs to run a system routine. System Calls are provided as commands in APL like Create(), Open(), Fork() etc. These system calls in APL translate to a series of stack operations followed by the <tt>INT</tt> machine instruction. <tt>INT</tt> instruction invokes an Interrupt Routine as described in Stage 5.</p>
				<p>A user program  invokes a system call by first pushing the registers, arguments and system call number into the process stack and then invoking <tt> INT </tt> instruction corresponding to the system call. </p>
		
				<p>For e.g. a system call in APL compiles to the a set of machine instructions like the one shown below.</p>
				<div class="syntax"> <pre>
PUSH <i>Argument_1</i>	// Push arguments to the stack
.
.
PUSH <i>Argument_n</i>
PUSH R0			// Push an empty space for RETURN VALUE
PUSH <i>System_Call_No</i> 	// Push system call number		
INT <i>number</i> 		// Invoke the corresponding INT instruction</div></pre>
				
				<p><b>FIGURE 1: Contents of the stack when a system call is exectued.</b> </p>
				 <img src="doc/syscallstack1.png" style="width:50%; float:left; margin-right:5%; ">
				 
				<p><b>Step 1</b> shows the stack operations done before an <tt>INT</tt> instruction (See machine instructions above). The arguments are pushed to stack in an order such that last argument comes on top. A push instruction <tt>PUSH R0</tt> is done to put an empty space for the return value in the stack. This space will store the value returned by the System Call. The return value of the system call can be fetched by the user program from this position. We can implement more than one system call using an Interrupt Routine. When control is passed to the interrupt routine, it identifies the system call the user intended to perform by a system call number. This system call number is pushed to the user stack. The interrupt routine will fetch this value from the stack and identify which system call is to be performed.</p>
				
				<p>
				 <b>Step 2</b> shows the contents of the stack when the <tt>INT</tt> instruction is executed. The <tt>INT</tt> instruction will push the value of <tt>IP + 2</tt> on to the stack. This is address of the next instruction that is to be executed after the control returns from the system call. When the control of execution returns from the system call, the register <tt>IP</tt> is set to the value on the top of the stack. This value is the address of the instruction after the <tt>INT</tt> instruction in the user program. The <tt>INT</tt> instruction passes control to the Interrupt Routine corresponding to the system call.</p>
	<br/><br/>



				

				<p><b>FIGURE 2: Contents of the stack when it returns back to the user program from an interrupt routine. Control returns from the interrupt routine  to user program using an <tt>IRET</tt> instruction.</b> </p>
				 <img src="doc/syscallstack2.png" style="width:50%; float:right; margin-right:5%; ">
 				
				<p><b>Step 1</b> shows the contents of the stack before the <tt>IRET</tt> instruction. This step shows the condition of the stack after the interrupt routine had performed all the required actions corresponding to the system call. Note that this is similar to Step 2 of the previous figure. However the interrupt routine will have filled the empty space for the <tt>RETURN VALUE</tt> with the required result after all the system call actions have been performed. In the previous figure this space would be empty.</p>
				
				<p>
				 <b>Step 2</b> shows the contents of the stack immediately after the <tt>IRET</tt> instruction. The value on the top of the stack will be popped and stored in the <tt>IP</tt> register. This value will be the address of the  instruction after the <tt>INT</tt> instruction in the user program. </p>
				 

			</p>
				<br/>
				
				 <p>In this stage you'll implement the Create system call. To do this, you must modify the OS Startup code and Interrupt 1 routine. Create system call is to create files in the XFS disk.  (See <a href="xos-spec.html#navsyscalls_file">File System Calls</a>).</p>


				<h6> Modifying the OS Startup Code</h6>
			 <p>In the last stage you have tested out the multiprogramming functionality by running two processes simultaneously. However to implement and test File System Calls  Create(), Delete(), Open(), Close(), Read(), Write() and Seek(), you may disable the timer and run the machine. </p>
			 
			 <p> Since in this stage, the machine is to be run in single processing mode without the timer interrupt, you do not need the OS Startup Code to load two programs. The OS Startup Code modifications done in Stage 6 can be discarded as it was done to test the timer interrupt routine. Modify the OS Startup Code you used in Stage 5 which loads only one process to memory. These additional tasks need to be performed by the new OS Startup Code before the <b>ireturn;</b> instruction for Create system call to work properly.</p>
				<ol>
				<li> When a file is created by the system call, a new FAT entry is to be created. The OS maintains a memory copy of the filesystem structures like <a href="xos-spec.html#navfiles_fat">FAT</a> and <a href="xos-spec.html#navfiles_dfl">Disk Free List</a>. The Disk Free List is a file system data structure which keeps track of used and unused blocks in the disk. (See <a href="xfs-spec.html#navdfl">Disk Free List</a> in XFS). The memory copy of these structures are changed by the OS when File System Calls are performed, and it is then committed back to the disk. Load <a href="xos-spec.html#navfiles_fat">FAT</a> from disk block 10 to memory page 5 and <a href="xos-spec.html#navfiles_dfl">Disk Free List</a> from the disk block 11 to memory page 6. Refer <a href="xos-spec.html#navmemorg">Memory Organization</a> and <a href="xfs-spec.html#navdiskorg">Disk Organization </a>. </li>
				</li>
				
				<li> You already have the instruction to load Interrupt routine 1 from the disk to the memory in stage 5.  Check if this instruction <tt><b>load (9, 3)</b></tt> is present in the OS Startup Code.  This instruction loads the Interrupt 1 routine residing in disk block 3 to memory page 9. (See <a href="xos-spec.html#navmemorg" >Memory Organization</a> and <a href="xfs-spec.html#navdiskorg">Disk Organization</a>).
					
				</li>
				</ol>
				
				<h6> Modifying Interrupt 1 Routine</h6>
				<p>
				The previous implementation of Interrupt 1 Routine to print <tt>SW Interrupt</tt> is to be discarded. Interrupt 1 is used by two system calls Create and Delete. The system call number is to be obtained from the stack. The system call number is at the 2nd position from the stack, i.e. SP - 1. This is explained in the figures given above. Since interrupt routines execute in kernel mode, you will need to calculate the physical address of SP using the formula described in Stage 6. Get the system call number in a register which is aliased as <tt>sysCallNo</tt>. Fetch the arguments from 3rd position onwards in the stack, i.e. SP - 2 onwards. Put the arguments in registers. </p>		
				 <p> Based on the <tt>sysCallNo</tt> perform the required actions.</p>	
				 A skeleton of the new Interrupt 1 Routine is given below. 
				</p>
				

				<div class="syntax">
				<pre>
alias physicalSP R8;
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
.
// Get system call no. from the stack and put it in registers
// Get arguments from stack and put it in registers
.
if ( sysCallNo == 1) then
	// Implementation of Create 
	.
	.
endif;
if ( sysCallNo == 4) then
	// Implementation of Delete
	.
	.
endif;	</pre>
				</div>

				<p>In this stage you will implement the Create System Call. </p>
				Create <br/>
				<i>System Call No</i>: 1 <br/>
				<i>Interrupt Routine No</i>: 1 <br/>
				<i>Arguments</i>: filename <br/>
				<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
				<br/>				
				<p> The Create system calls takes the <tt>filename</tt> of the file to be created as the argument. It checks for a free block in the disk, and if its found, it will allocate this block as the basic block of the new file. It will create a FAT entry for the newly created file. Detailed instructions on how to get this done is given below.
				
				</p>



				<ol>
				<li><p> First of all, the memory copy of the <a href="xfs-spec.html#navdfl">disk free list</a> is searched till block number 447 to find a free block. Blocks 448 - 511  are reserved for <a href="xfs-spec.html#navdiskorg">swap area</a> which will be used for virtual memory management (<a href="roadmap.html#navstage9">Stage 10</a>). A free block is indicated by a 0 entry in the Disk Free List. The index of such an entry gives the block number of the free block.
				
				</li></p>
				<li> <p> If no free block is found, return from the system call with return value -1, indicating failure. To do this, put -1 at the 2nd position from the top of stack as shown in Figure 2, and use <b>ireturn;</b> instruction. This will pass the control back to the user program. The user program can fetch the return value from the appropriate position in the stack. </li></p>
				
				<li>If a free block is found, it is used as the <a href="xfs-spec.html#navfile">basic block</a> of the file to be created. A basic block of the file stores the block numbers of the data blocks of the file. The data blocks will have the contents of the file. </li></p>
				
			

				<li> <p>Create system call has only 1 argument, <tt>filename</tt>. You have already fetched the arguments and placed them in registers. 
				</li></p>
				
				<li> <p>The memory copy of the <a href="xos-spec.html#navfiles_fat">FAT</a> is to be searched with this <tt>filename</tt> to check a file with the same name already exists. If it exists return from the system call with 0, indicating success. For convenience you may use the <a href="spl-spec.html#navconst">predefined constant</a> <tt>FAT</tt> in SPL which stores the address of memory copy of FAT.
				</li></p>

				<li> <p>Next, the memory copy of the <a href="xos-spec.html#navfiles_fat">FAT</a> is searched for a free entry. A free entry in the FAT is indicated by -1 in the entry for basic block (word 2 of each FAT entry). If no free entry is found, return with -1, indicating failure.  </li></p>
				
				<li> <p>If a free FAT entry is found, set the <b>File Name</b> field with the filename given as argument. The <b>File Size</b> field in the FAT entry is initialized to 0. The <b>Block No. of Basic Block</b> is set to the block number of the free block found in Step 1. 
				</li></p>

		
				<li><p> Scratchpad is a memory page used to load a disk block from disk to memory for reading or editing. It uses the same memory page as OS Startup Code. See <a href="xos-spec.html#navfiles_scratchpad">scratchpad</a>. Load the <a href="xfs-spec.html#navfile">basic block</a> of the file from the disk to the <a href="xos-spec.html#navfiles_scratchpad">scratchpad</a>. 
				</li></p>
				<li> <p>All the words in the basic block loaded to the scratchpad must be set to 0. This indicates that there are no data blocks currently for this file. After this is done, the basic block residing in the scratchpad needs to be stored back to the disk. Store the memory page 1 (corresponds to the scratchpad) to disk block number corresponding to the basic block of the newly created files. Use the <tt>store</tt> statement in SPL to do this. (See <a href="spl-spec.html#navstatements">statements</a> in SPL). </li></p>

				<li> <p> The entry in the Disk Free List for the basic block is set to 1, indicating that it has now been allocated.The updated copies of <a href="xos-spec.html#navfiles_fat">FAT</a> and <a href="xos-spec.html#navfiles_dfl">Disk Free List</a> in the memory are then stored back to the disk.</li></p>
				
				<li><p> Return from the system call with return value 0, indicating success. An <b>ireturn</b> instruction is used to transfer control back to user program which invoked the system call. </li></p>
	
				</ol>
			<h6>Making things work!</h6>
			<ol>
				<li><p>Compile the OS Startup Code and load the compiled output file to the XFS Disk</p></li>
				<li><p>Compile the Interrupt 1 Routine and load the compiled output file to the XFS Disk</p></li>
				<li><p>Create a test APL program which uses the Create system call. A sample program is given below.</p></li>
				<div class="syntax"><pre>decl
	integer status;
enddecl
integer main()
{
	status = Create("myfile.dat");
	print(status);
	return 0;
}</pre>
</div> This program invokes Create system call to create a file named <tt>myfile.dat</tt>. It prints the value returned by the Create system call.
</p></li>
				<li> <p> Compile the above given APL program using APL compiler. Load it as the INIT program to XFS Disk using the XFS interface.</p></li>
				<li><p> Run the machine with the timer disabled</p><div class="syntax"> $HOME/myxos/xsm/xsm --timer=0</div></li>
				
			</ol>
			<p>If the system call execution did not fail in between 0 will be printed and the machine will halt. The correct output is given below</p>
			<tt><pre>
0 
Machine is halting     </pre>
			</tt>
			 However, this does not ensure that file is created properly. To ensure the proper functioning of the Create system call, invoke the XFS interface and use the <b>ls</b> command to see if the file <tt>myfile.dat</tt> is listed. You may use <b>copy</b> command to check if the contents of FAT and Disk Free List are set correctly by the Create system call.
			


			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>










<!-- ********************************************* STAGE 8 *************************************** -->

			<article  id="navstage8" class="grid col-full">
			<h2>Stage 8: Playing with files</h2>
			<p>You have already created files using the <b>Create</b> system call. In this stage, you will implement the <b>Open</b>, <b>Close</b>, <b>Delete</b>, <b>Write</b>, <b>Seek</b> and <b>Read</b> system calls. </p>
				


			<p>XOS uses two data structures to maintain information about opened files. They are <a href="xos-spec.html#navfiles_swoft">System-Wide Open File Table</a> and <a href="xos-spec.html#navpromgmt_pcb">Per-Process Open-File Table</a>. There is one system-wide open file table for XOS which stores the FAT index corresponding to each opened file and the number of times that file has been opened. There is a per-process open file table for every process in its PCB. The per-process open file table stores the system-wide open file table index corresponding to an open instance of a file, and the LSEEK position of this open instance, which indicates the word in the file to which the process currently points to for read/write operations. A single file may be opened more than once by the same or different processes. Each open instance has an entry in the corresponding per-process file table. But there will only be one entry corresponding to an opened file in the System Wide open file table. <b>File Open Count</b> field of the System Wide Open File Table entry stores the number of open instances of a file. </p>

			<h6>Modifying OS Startup Code</h6>
			<ol>
			<li> <p>All entries of the <a href="xos-spec.html#navfiles_swoft">System-Wide Open File Table</a> must be set to invalid initially. This is because no files are open when the OS starts. An invalid entry is indicated by -1 in the <b>FAT Index</b> field of all entries. The <b>File Open Count</b> field of all entries must be set to 0.</b>. For convenience, you may use the predefined constant <tt>FILE_TABLE</tt> in SPL which stores the address of the System Wide Open File Table. </li></p>
			
			
				<div class="syntax">
				<pre>
alias counter R8;			
counter = 0;
while ( counter <  128) do			// 64 entries, each of size 2 words
	[ FILE_TABLE + counter + 0] = -1;	// Set FAT Index to -1
	[ FILE_TABLE + counter + 1] =  0;	// Set File Open Count to 0
	counter = counter + 2;			// Move to next entry
endwhile;					</pre>
				</div>
				<li> <p>The only process OS Startup Code loads to memory is the INIT process. Hence all the entries of the Per-Process Open File Table of the INIT process must be best to invalid. This is because no files are opened by the INIT process. An invalid Per-Process File Table entry is indicated by -1 in both the fields (Pointer to System-Wide Open File Table entry and LSEEK position).  </li>	</p>
				
				<li> <p>File System Calls are implemented using interrupt routines 1 to 4. You have already written code to load interrupt routine 1 from the disk to memory. Similarly add instructions to load Interrupt Routines 2, 3 and 4 from disk to memory. (See <a href="xos-spec.html#navmemorg" >Memory Organization</a> and <a href="xfs-spec.html#navdiskorg">Disk Organization</a>). </li>		</p>
			</ol>

			<h6>Programming Interrupt Routines</h6>
			<p>As done for Create system call, every system call is associated with an interrupt routine and a system call number.The various file system calls and their corresponding interrupt routines are given in the table below.</p>
				<table class="doctable" style="width:50%">
					<tr><th>System Call Name</th><th>System Call #</th><th>Interrupt Routine #</th></tr>
					<tr><td>Create</td>			 <td>1</td>				<td> 1</td> </tr>
					<tr><td>Open</td>			<td>2</td>				<td> 2</td> </tr>
					<tr><td>Close</td>			<td>3</td>				<td> 2</td> </tr>
					<tr><td>Delete</td>			<td>4</td>				<td> 1</td> </tr>
					<tr><td>Write</td>			<td>5</td>				<td> 4</td> </tr>
					<tr><td>Seek</td>			<td>6</td>				<td> 3</td> </tr>
					<tr><td>Read</td>			<td>7</td>				<td> 3</td> </tr>
				</table>
			<br/>
			<p>The system call number must be fetched from the stack and conditionally the corresponding system call actions need to be performed. Actions that needs to be taken for each system call is discussed in detail in this stage. After programming the interrupt routine, it must be compiled using SPL compiler, and loaded to XFS disk using XFS interface. </p>
			<p>To check if the system call is functioning properly, make application programs which invoke the system call. Compile it using APL compiler and load it to disk as the INIT program. Run the machine by <b>disabling the timer</b>. You may use the XFS interface to check the working of file sytem calls.</p>
			
			<p> Detailed information and actions corresponding to each system call is given below.</p>
			
			
			
			
			<h5> Open System Call</h5>
			<i>Description:</i> The Open system call is used to open a file present in the XFS disk. <br/>
			<i>System Call No</i>: 2 <br/>
			<i>Interrupt Routine No</i>: 2 <br/>
			<i>Arguments</i>: filename of the file to be opened <br/>
			<i>Return Value</i>: Index of open instance in per-process file table (Success) or -1 (Failure) <br/> 
			<ol>
				<li><p>First, you need to check if a file with the given <b>filename</b> exists in the disk. To do this, memory copy of FAT is searched for the <tt>filename</tt> given as argument to the system call. Steps to obtain the argument from the stack is explained in detail in Stage 7. If the entry is not found, -1 is returned, indicating failure. Otherwise, store the index of the FAT entry in a register.</li></p>

				<li><p> If the file is  already opened, there will be an entry corresponding to this file in the System wide Open file table, which needs to be updated. Otherwise an entry in the system-wide open file table needs to be created. To do this, search the <a href="xos-spec.html#navfiles_swoft">System-Wide Open File Table</a> for the FAT entry Index found in the previous step. </p>
					<ul>
					<li>If an entry with the FAT index is found, store the index of the matched entry in a register.  </li>
					<li>Otherwise, search for a free entry in the System-Wide Open File Table. A free entry is indicated by -1 in the <b>FAT Index</b> field in the System-wide Open File Table. If there are no free entries. return from the system call with return value -1. If a free entry is found, store the index of the entry in a register. 
					</li>
				
					</ul>
			 </li></p>
				
			

				<li> <p>Every process will have a <a href="xos-spec.html#navpromgmt_pcb">Per-Process File Table</a> in its PCB. This stores the details of open instances of files by that process. Note that a single file may be opened more than once by the same process. Find the location of the PCB of the current process by obtaining the Process ID using the method described in Stage 6. A free entry is searched in the <a href="xos-spec.html#navpromgmt_pcb">per-process open file table in the PCB</a> of the process. A free entry is indicated by -1 in the first field (Pointer to <a href="xos-spec.html#navfiles_swoft">System-Wide Open File Table</a>). If there are no free entries -1 is returned by the system call. Otherwise, store the index of the Per-process file table entry in a register. Set the first field (<b>Pointer to System-Wide File Table Entry</b>) of this entry to the index of the System-wide open file table entry stored in Step 2 and set <b>LSEEK Position</b> field to 0.  				
				</li></p>

		

				<li> <p> Set the <b>FAT Index</b> field of the System Wide file table entry found in Step 2 with the FAT Index found in Step 1. This field in the system wide open file table points to the FAT entry for the file.  Increment the <b>File Open Count</b> field in the system-wide open file table by 1. XOS keeps track of number of times a file has been opened in the <b>File Open Count</b> field for each open file in the System-wide open file table.  </li></p>
			
				<li> The index of the entry in the per-process open file table created in step 3 is returned as a return value of the system call. This is known as the file descriptor. </li>
			</ol>


			<h5> Close System Call </h5>
			<i>Description</i>: Closes a file opened by the process.<br/>
			<i>System Call No</i>: 3 <br/>
			<i>Interrupt Routine No</i>: 2 <br/>
			<i>Arguments</i>: fileDescriptor <br/>
			<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
			<br/>
			<p>The argument, <b>fileDescriptor</b> is the index of per-process open file table entry for the open instance of the file to be closed. When a file's open instance is closed this entry is deleted and the file open count in the system wide open file table is decremented. Specific tasks to be done by the Close is given below  </p>
			<ol> 
				<li> Return from the system call with -1, indicating failure if the <tt>fileDescriptor</tt> is invalid. A valid <b>fileDescriptor</b> will have value from 0 to 7.</li>
				<li> Index into the per-process open file table in the PCB of the process with the <b>fileDescriptor</b>. If the entry is invalid, which is indicated by a -1 in the first field of the entry (pointer to System-wide Open File Table entry), return from the system call with -1, indicating failure.</li>
				<li> Otherwise, using the <b>Pointer to System Wide Open File Table Entry</b>b> field, index to the System Wide Open File Table and decrement <b>File Open Count</b> field by one. If the  becomes 0, invalidate the entry. An entry in the system-wide open file table is invalidated by setting the <b>FAT Index</b> entry to -1. </li>
				<li> Now invalidate the Per-Process Open File Table entry, by setting the fields to -1</li>
				<li> Return from system call with 0 (success).
				 </li>
			</ol>

			<h5> Delete System Call</h5>
			<i>Description:</i> Deletes a file in the disk with the filename given as argument. <br/>
			<i>System Call No</i>: 4 <br/>
			<i>Interrupt Routine No</i>: 1 <br/>
			<i>Arguments</i>: filename <br/>
			<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
			<br/>
			
			<p> The delete system call will only work if the file exists, and it is not opened by any process. If both the conditions are satisfied then mark the entries corresponding to the basic block and data blocks of the file as unused in the disk free list. Also, the FAT entry corresponding to the file must be invalidated. Detailed instructions to do this is given below.
			</p>

			<ol>
				<li> Check if the file to be deleted exists in the disk. To do this, search the memory copy of <a href="xos-spec.html#navfiles_fat">FAT</a> for the <tt>filename</tt> specified as argument. If it is not found, return from the system call with -1 (failure). If an entry is found, store the index in a register.</li>
				<li> Search the System Wide Open File Table to see if the file has been opened. If a file is opened, an entry with the FAT index found in the previous step will be present in the System Wide Open file table. If it is opened, return from the system call with -1 (failure) </li>
				<li> Otherwise, follow the steps to delete the file
					<ul>
					<li>Load the <a href="xfs-spec.html#navfile"><b>Basic Block</b></a> to the <a href="xos-spec.html#navfiles_scratchpad">Scratchpad</a>. The Basic Block contains the block numbers of all the data blocks of the file. The data blocks must be set as unused in the memory copy of the <a href="xfs-spec.html#navdf">Disk Free List</a>
					</li>
					<li> Set the entry for the basic block of the file in the Disk Free List to 0 (unused)</li>
					<li> Invalidate the <a href="xos-spec.html#navfiles_fat">FAT</a> entry by setting -1 in the <b>filename</b> filed and  <b>Basic Block Number</b> field.</li>
					</ul>
				</li>
				<li> Store back  the FAT and Disk Free List from the memory to the disk. These data structures are actually disk data structures. To change the entries of these structures, they have a corresponding memory copy. Once a change is made, the memory copies must be stored back to the disk to reflect the changes on the disk as well.</li>
				<li> Return from the system call with 0 (success)</li>
			</ol>

			<h5> Write System Call </h5>	
			
			<i>Description:</i> Used to write a single word to a file opened by the process<br/>
			<i>System Call No</i>: 5 <br/>
			<i>Interrupt Routine No</i>: 4 <br/>
			<i>Arguments</i>: 1. fileDescriptor, 2. wordToWrite <br/>
			<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
			<br/>
			
		  	<ol>
				<li><p> Return from the system call with -1, indicating failure if the <tt>fileDescriptor</tt> specified as argument is invalid. A valid <b>fileDescriptor</b> will have value from 0 to 7.</li></p>
				
				<li> <p>Index into the per-process open file table in the PCB of the process with the <b>fileDescriptor</b>. If the entry is invalid, which is indicated by a -1 in the first field of the entry (pointer to System-wide Open File Table entry), return from the system call with -1, indicating failure.</li></p>
				
				<li> <p>If a valid entry exists, store the <b>Pointer to System Wide Open File Table Entry</b> 
				field and <b>LSEEK position</b> field in registers.</li></p>
				
				<li><p> Using the <b>Pointer to System Wide Open File Table Entry</b>, index to the System Wide Open File Table to get the FAT Index field.   </li></p>
				
				<li> <p>Using the FAT Index, fetch the <b>Basic Block</b> from the FAT and load it to the scratchpad. This is done to find the block to which the word is to be written to. The basic block contains block numbers of all data blocks of the file.</li></p>
				
				<li> <p>Using LSEEK position, find the block number to which the word is to be written to. 
				LSEEK position is the word number in the file at which reading or writing takes place. The LSEEK position divided by 512 gives the index of the basic block entry. This entry will have the block number of the data block to which the word is to be written. If this entry is invalid indicated by -1, then allocate a new block in the following way.
					<ul>
						<li> Find a free block in the disk. To do this traverse through the memory copy of the <a href="xfs-spec.html#navdfl">Disk Free List</a> till the entry for block 447 (Blocks 448 onwards is Swap, which is reserved for virtual memory management).
						<li> If no free block is avaliable. Return from the system call, with return value -1 indicating failure <li>
						<li> Otherwise, set 1 in the entry for the  free block in the Disk Free List.</li> 
						<li> Add this block number to the basic block of the file.</li>
						<li> Commit the basic block from scratchpad back to the disk. </li>
						<li> Increment the <tt>file size</tt> in the FAT entry by 1. </li>
						<li> Commit the FAT and Disk Free List from the memory to the disk. </li>
					</ul>
				</li></p>
				<li> Fetch the block from the disk to the scratchpad. </li>
				<li> Write the argument <b>wordToWrite</b> to this block with the offset calculated using LSEEK position. LSEEK modulo 512 will give the offest into the block at which the word is to be written to.</li>
				<li> Store this block back to disk.</li>
				<li> Increment LSEEK Position by 1 in the Per-Process Open File Table. This is because one new word has been written and LSEEK position must be pointing to the next word. </li>
				<li> Return from the system call with 0 (success)</li>
		  	</ol>

			<br/>
		  	<h5> Seek </h5>
			
			<i>Description</i>: Changes the LSEEK position
			<i>System Call No</i>: 6 <br/>
			<i>Interrupt Routine No</i>: 3 <br/>
			<i>Arguments</i>: 1. fileDescriptor 2. newLseek <br/>
			<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>


		  	<ol>
				<li><p> Return from the system call with -1, indicating failure if the <tt>fileDescriptor</tt> specified as argument is invalid. </li></p>
				
				<li> <p>Index into the per-process open file table in the PCB of the process with the <b>fileDescriptor</b>. If the entry is invalid, return from the system call with -1, indicating failure.</li></p>
				
				<li> <p>If a valid entry exists, store the <b>Pointer to System Wide Open File Table Entry</b> 
				field in a register. </li></p>
				
				<li> <p>Using the <b>Pointer to System Wide Open File Table Entry</b> field, index to the System Wide Open File Table to get the FAT Index Entry.   </li></p>
				
				<li> <p>Fetch the <b>file size</b> of the file from the FAT and store it in a register. </li></p>
				<li> <p>Check if the new LSEEK position specified as argument is valid. If it is not valid, return from the system call with -1, indicating failure. LSEEK position is valid if the word number lies 0 and number of words in the file. Number of words in a file can be calculated using <b>file size</b> (or number of blocks) x 512 (block size). Change the <b>LSEEK</b> in the per-process file table to <b>newLseek</b>. Return with 0 (indicating success).</li></p>
				
				
		  	</ol>

		  	<h5>Read</h5>
			<i>Description</i>: Reads a word from a file to the variable passed as argument. <br/>
			<i>System Call No</i>: 7 <br/>
			<i>Interrupt Routine No</i>: 3 <br/>
			<i>Arguments</i>: 1) fileDescriptor 2) wordRead<br/>
			<i>Return Value</i>: 0 (success) and -1 (failure) </br>
			<br/>

		  	<ol>
				<li><p> Return from the system call with -1, indicating failure if the <tt>fileDescriptor</tt> specified as argument is invalid.</li></p>
				
				<li> <p>Index into the per-process open file table in the PCB of the process with the <b>fileDescriptor</b>. If the entry is invalid return from the system call with -1, indicating failure.</li></p>
				
				<li> <p>If a valid entry exists, store the <b>Pointer to System Wide Open File Table Entry</b> 
				field and <b>LSEEK position</b> field in registers.</li></p>
				
				<li><p> Using the <b>Pointer to System Wide Open File Table Entry</b>, index to the System Wide Open File Table to get the FAT Index field.  </li></p>
				
				<li> <p>Using the FAT Index, fetch the <b>Basic Block</b> from the FAT and load it to the scratchpad. This is done to find the block from which the word is to be read. The basic block contains block numbers of all data blocks of the file.</li></p>
				
				<li> <p>Using LSEEK position, find the block number from which the word is to be read. 
				</li></p>
				
				<li><p> Fetch the block from the disk to the scratchpad. </li></p>
				<li> <p> Read from this block using the offset calculated using LSEEK position. </li></p>
				<li> <p>The word that is read is stored in the stack in position of Argument 2 (wordRead). The application programmer using this system call, gives a variable as the 2nd argument for the system call. This word that is read will get stored in that variable. This is similar to Call-by-reference argument passing mechanism in programming languages. To do this store the word read to <tt>physicalSP - 2</tt>.</li> </p>
				<li><p> Increment LSEEK Position by 1 in the Per-Process Open File Table. This is because a word is read and LSEEK position must be pointing to the next word. </li></p>
				<li> Return with 0, indicating success </li>
		  	</ol>
		  	
		  	


			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	
			









<!-- ************************************************ STAGE 9 *************************************** -->
			
			
			<article  id="navstage9" class="grid col-full">
			<h2>Stage 9: Process and Machine System Calls</h2>
			<h2>Stage 9: Process and Machine System Calls</h2>
			<p>  
			There are several process system calls which are used to create processes, load a new process to an existing process, exit from a process. These system calls are <b>Exec, Fork and Exit</b>. The only machine system call in XOS is <b>Halt</b> which is used to shut down the machine.</p>
			<br/>

			 <h5>Fork system call :</h5>
			 The<a href="xos-spec.html#navsyscalls_process"> Fork </a> system call is used to replicate the process which invoked this system call in the memory. <br/>
			 <i>System Call No</i>: 8 <br/>
			<i>Interrupt Routine No</i>: 5 <br/>
			<i>Arguments</i>: None<br/>
			<i>Return Value</i>: PID of the process created (success) or -1 (failure)</br>

			</br>
			Interrupt 5 Routine must be programmed in SPL, compiled and loaded to disk. It must perform the following tasks.
		  	<ol>
			<li> The <em>Ready list</em> of PCBs is traversed to find a PCB with State 0 (terminated).</li>
			<li> If no such PCB is found, -1 is returned. </li>
			<li> The index of the PCB in the Ready List is the PID of new process created. It is stored in a register.</li>
			<li> The pages used by the parent process is replicated in the following way</li>
				<ul>
					<li> The page table of the parent process is checked to count the number of valid pages. The <a href="xos-spec.html#navmemmgmt_mfl">memory free list</a> is checked to find an equal number of free pages. If this check fails, return with -1 indicating failure. </li> 
					<li> Otherwise an equal number of pages are allocated by updating the memory free list.</li>
					<li> Make corresponding entries in the child process' page table. The child's PTBR (address of its page table) is computed using PID stored in Step 3 </li>
				</ul>
			<li> The current register values of the parent process are (except PTBR)  copied to the child process' PCB. The entry for PTBR is the child's PTBR computed in the previous step. (<b>DO NOT</b> copy values from parent's PCB to child's PCB as it may not be equal to current values) </li>

			<li> The Per-Process Open File table of the parent process is not copied to child's PCB. Instead invalidate all entries in child's Per-Process Open File Table </li>
			<li> Control is passed back to the parent process using <b>ireturn</b>.</b>
		  	</ol>
		  	<b> OS Startup Code</b> is modified to 
		  		<ul>
		  			<li>Load Interrupt 5 Routine. (The code to load the 2nd process in the previous stage can now be removed)
		  			</li> 
		  			<li> The entries for pages 0 to 15 in the <a href="xos-spec.html#navmemmgmt_mfl">memory free list</a> is marked as used (set 1) and others as unused (set 0). Pages 0 - 15 are reserved for OS structures. See <a href="xos-spec.html#navmemorg"> Memory Organization </a>
		  			</li> 
		  		</ul>
		  	To test Fork(), use Exec with program to print odd numbers after issuing a Fork from the INIT program (to print even numbers). 
			
			</br><br/></br>
			<h5>Exec system call :</h5>
			The <a href="xos-spec.html#navsyscalls_process">Exec </a>system call is used to load and run a new process from a currently running process. The current process is overwritten by new process i.e. the process data structures of the current process is used by the new process. </br>
			<i>System Call No</i>: 9 <br/>
			<i>Interrupt Routine No</i>: 6 <br/>
			<i>Arguments</i>: filename <br/>
			<i>Return Value</i>: 0 (success) and -1 (failure) </br>
		
			 <br/>
			 The Interrupt 6 Routine is to be programmed in SPL, compiled and loaded to the disk. 
			 <b>OS Startup Code</b> is modified to load Interrupt Routine 6 from the disk to memory. </br>

			 The Interrupt 6 Routine performs the following actions.
			 <ol>
		 		<li> Get the filename to a register from the stack </li>
		 		<li> Search for the filename in the memory copy of FAT. If it doesn't exist return -1 (indicating failure). </li>
		 		<li> Otherwise fetch the basic block (location is obtained from FAT) and place it in the <a href="xos-spec.html#navfiles_scratchpad">scratchpad</a>.
		 		</li>
		 		<li> Load the blocks of the file (a maximum of 3 blocks) to the memory in pages of the current process.</li>
		 		<li> Close all files opened by the current process by following the steps in <b>Close()</b> system call </li>
		 		<li> SP is reset to 3*512.  </li>
		 		<li> 0 is stored in 19*512 (physical address of the stack) to set IP by the <b>ireturn</b> instruction </li> 
				<li> Return from the system call with 0 (indicating success).</li>
			 </ol>

			 <b>Exec</b> system call can be tested out by modifying the INIT program, by adding an <a href="apl-spec.html#navexec">Exec</a> call in it. 
	</br>	</br><br/>

			<h5>Exit system call :</h5>
			This system call is used to terminate the execution of the process which invoked it. Exit removes this process from the memory. If there is only one process, it halts the system.<br/>
			<i>System Call No</i>: 10 <br/>
			<i>Interrupt Routine No</i>: 7 <br/>
			<i>Arguments</i>: None<br/>
			<i>Return Value</i>:-1 on failure, exits on success </br>
			

		</br>	</br>
			<h5>Halt system call :</h5>
			<i>System Call No</i>: 0 <br/>
			<i>Interrupt Routine No</i>: 7 <br/>
			<i>Arguments</i>: None<br/>
			<i>Return Value</i>:-1 on failure, halts on success </br>
			If there is only one process in memory, it halts the system. Otherwise returns -1.
			<br/><br/>
			Both Exit and Halt are implemented in Interrupt 7 Routine. It is to be programmed in SPL, compiled and loaded to the disk using XFS Interface. It does the following tasks 
				<ol>
					<li> If there is only one process, halt the system using <tt>HALT</tt> instruction irrespective of the system call </li>
					<li> If its Exit system call, do the following actions</li>
						<ol style="list-style-type:lower-roman;">
							<li> Find the PCB of the current process using PTBR 
							</li>
							<li> Close all files opened by the process as done for <b>Close</b> system call</li>
							<li> Set the STATE in the PCB to 0.  </li>
							<li> Invalidate all entries in its per-process page table (Set <tt>Address</tt> field to -1) </li>
							<li> Find the next waiting process from the  <a href="xos-spec.html#navpromgmt_readylist">Ready List of PCBs</a></li>
							<li> Get the IP from its PCB and store it in its stack (Compute physical address of its SP)</li>
							<li> And use <b>ireturn</b> instruction to transfer control.</li>
						</ol>
					<li> Otherwise, exit with -1 </li>	

				</ol>
	 		<b>OS Startup Code</b> is modified to load Interrpt 7 from disk to memory. 

			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>











<!-- ************************************************ STAGE 10 *************************************** -->
			
			
			<article  id="navstage10" class="grid col-full">
			<h2>Stage 10: Exception Handling and Demand Paging</h2>
			<p> 
				<a href="xos-spec.html#navsysroutines_exhandler">Exception Handler</a> in XOS handles exceptions caused by machine. When an exception occurs, the machine sets the <tt>EFR</tt> (Exception Flag Register) and calls the Exception Handler in Page 7. You must read about <a href="xsm-spec.html#navexcep">Exceptions</a> before proceeding .
			</p>


			This stage involves programming the Exception handler in SPL, compiling and loading it to disk. The OS Startup Code must be modified to load the exception handler from disk to memory on startup. 

			The exception handler must do the following :
			<ol>
				<li> The details corresponding to the exception is stored in EFR register. The individual values in EFR must be extracted to registers. 
					<div class="syntax">
						<pre>
Cause = EFR % 10;		// Gets value of cause field (size 1 char)
VPagenum = (EFR / 10) % 100;    // Gets value of BadVAddr 
Ip_addr = (EFR/1000);		//Gets value of IP at the point of exception
</pre>
						
					</div>
				</li> 
				<li> 
					If <tt>Cause</tt> is a value other than 0, Display the error and exit the process which caused the exception. The process can be identified by the current <tt>PTBR</tt> value. Follow the steps done in Exit system call implementation. 
				</li>
				<li>
					If <tt>Cause</tt> it is 0 (Page Fault), the following actions have to be performed.
					<ol style="list-style-type:lower-roman">

						<li> Allocate a free page by searching through the memory free list. If a free page is not found, follow the page replacement technique, described later to find a free page. Store its page number in a register </li>
						<li> Get the <tt>physical page number</tt> field corresponding to <tt>VPagenum</tt> from the Per-Process page table of process that caused the exception.  </li>
						<li> If the <tt>physical page number</tt> field of the <a href="xos-spec.html#navpromgmt_page">Per-Process Page Table</a> is a disk block number, load the disk block to the free page allocated in Step i. Otherwise, this step can be omitted. </li>
						<li> Set the Per-Process Page Table entry corresponding to  <tt>VPagenum</tt> with the page number of free page and set the <tt>Auxiliary flag</tt> as 11. (Valid and Referenced) </li>
						<li> Put Ip_addr to the memory location pointed to by the physical address of SP. </li>
						<li> Return to USER Mode using <b>ireturn</b> instruction. </li>
					</ol>
				</li>
				<br/>
			</ol>
				<h6>Page-Replacement Algorithm</h6>
				<p>The page replacement technique used in XOS is a <i>Second Chance Algorithm</i> which uses the <i>reference bits</i> in the auxiliary information. The steps are as follows
					<ol>
						<li>
						It scans the valid entries in the  Per-Process Page Tables of all processes in a circluar fashion and checks for a page with reference bit '0'.
						</li>
						<li>
						The scanning starts from the current page table entry which issued a page fault.
						</li>
						<li> Whenever a page with reference bit '1' is encountered it is set to '0' and goes to the next page, giving a referenced page a second chance. </li>
						<li> When a page with reference bit '0' is encountered it is selected as the victim page. Then </li>
							<ol style="list-style-type:lower-roman">
								<li>  Memory copy of Disk Free List is scanned for a free block in the swap area (blocks 448 - 511). </li>
								<li> If no free block is found the corresponding process will be terminated	</li>
								<li> If a free block is found, the victim page is stored on that block and memory copy of Disk Free List is updated. </li>
								<li>The entry for the victim page in the Per-Process Page Table is updated with the address of this block and is set as invalid. </li>
							</ol>

			</ol>
			<h6>Modifications to OS Startup Code and Exec system calls</h6>
			When a process is loaded, only the disk addresses of the corresponding code blocks needs to be set in the page table and its <tt>Auxiliary Information</tt> is set to 00 (Invalid and Unreferenced). Put the <tt>Physical Address</tt> field of remaining entries are set to -1 with  <tt>Auxiliary Information</tt>  as "00". The disk blocks need not be loaded initially. It will be loaded by <a href="xos-spec.html#nnavmemmgmt_vm">pure demand paging strategy</a> when required.
			<br/>
			<h6> Modifications to Fork </h6>
			For Fork system call, when it copies the address space, duplicate all valid addresses as done earlier. If the entry in the page table of the parent process is invalid, 
				<ul>
					<li>
						If it is a disk address less than 448 (not swap area), copy the entry directly to the page table of the child.
					</li>
					<li>
						If it is a disk address >= 448 (swap area), check the disk free list and get a free swap block. Copy the contents of current swap block to the newly allocated swap block by using scratchpad. Set the page table of the child with the newly allocated swap block number and copy the <tt>Auxiliary Information</tt> from the parent's page table entry. 
					</li>
					<li>
						If the address is -1, do nothing.
					</li>
				</ul>


			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>









<!-- ************************************************ STAGE 11 *************************************** -->


			<article  id="navstage11" class="grid col-full">
			<h2>Stage 11: Making a console </h2>
			<p> 
				The final stage is to make the INIT  process act like a console. INIT written in APL, should be an infinite loop, which takes in  filenames. This filename should correspond to the program to be executed.
				It should <a href="apl-spec.html#navfork"><b>Fork</b></a> itself and <a href="apl-spec.html#navexec"><b>Exec</b></a> using the filename. Appropriate errors must be reported. 
			 </p>

			
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>
			 <br/><br/>
 			<center><h6>AND THAT'S YOUR OWN </h6><img src="img/logo-img.jpeg" style="margin:0;  width:40px"></center>
			</article>
							
							
			
		</div> <!-- 100%articles-->

		
		</section>	
		
		
		
	</div> <!--main-->
<div class="divide-top">
	<footer class="grid-wrap">
		<ul class="grid col-one-third social">
			<li><a href="http://github.com/XOS-NITC">Github</a></li>
		</ul>
	
		<div class="up grid col-one-third ">
			<a href="#navtop" title="Go back up">&uarr;</a>
		</div>
		
		<nav class="grid col-one-third ">
			<ul><li><a href="index.html" >Home</a></li>
				<li><a href="about.html">About</a></li>
				<li><a href="documentation.html">Documentation</a></li>
				<li><a href="downloads.html">Downloads</a></li>
				<li><a href="roadmap.html">Roadmap</a></li></ul>
			</ul>
		</nav>
	</footer>
</div>
</div>

<!-- Javascript - jQuery 
<script src="http://code.jquery.com/jquery.min.js"></script>-->
<script src="js/jquery-1.7.2.min.js"></script>
<script>window.jQuery || document.write('<script src="js/jquery-1.7.2.min.js"><\/script>')</script>

<!--[if (gte IE 6)&(lte IE 8)]>
<script src="js/selectivizr.js"></script>
<![endif]-->

<script src="js/scripts.js"></script>

<!-- Asynchronous Google Analytics snippet. Change UA-XXXXX-X to be your site's ID. -->
<script>
  var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
</body>
</html>
