<!DOCTYPE html>

<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->

<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->

<head>
	<meta charset="UTF-8">
	
	<!-- Remove this line if you use the .htaccess -->
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

	<meta name="viewport" content="width=device-width">
	
	<meta name="description" content="Build a simple operating system">
	
	<title>Roadmap // eXperimental Operating System</title>
	<link rel="shortcut icon" type="image/png" href="favicon.png">
	
	<!--<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>-->
	<link rel="stylesheet" href="css/style.css">
	
	<!--[if lt IE 9]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
</head>



<body>
<!-- Prompt IE 7 users to install Chrome Frame -->
<!--[if lt IE 8]><p class=chromeframe>Your browser is <em>ancient!</em> <a href="http://browsehappy.com/">Upgrade to a different browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to experience this site.</p><![endif]-->

<div class="container">

	<header id="navtop">
		<a href="index.html" class="logo fleft">
			<img src="img/logo.png" alt="Designa Studio">
		</a>
		
		<nav class="fright">
			<ul><li><a href="index.html" >Home</a></li>
				<li><a href="about.html">About</a></li>
				<li><a href="documentation.html" >Documentation</a></li>
				<li><a href="downloads.html">Downloads</a></li>
				<li><a href="roadmap.html" class="navactive">Roadmap</a></li></ul>
			</ul>
		</nav>
	</header>


	<div class="services-page main grid-wrap">

		<header class="grid col-full">
			<hr>
			<p class="fleft">Roadmap</p>
		</header>


		<aside class="grid col-one-quarter mq2-col-full">
		
			<menu>
				<ol style="list-style-type:decimal">
					<li><a href="#navstage1" class="sec">Setting up the System</a></li>
					<li><a href="#navstage2" class="sec">Understanding the Filesystem</a></li>
					<li><a href="#navstage3" class="sec">Starting the machine</a></li>
					<li><a href="#navstage4" class="sec">Running a user program</a></li>
					<li><a href="#navstage5" class="sec">Interrupts</a></li>
					<li><a href="#navstage6" class="sec">Multiprogramming</a></li>
					<li><a href="#navstage7" class="sec">Creating Files</a></li>
					<li><a href="#navstage8" class="sec">Playing with Files</a></li>
					<li><a href="#navstage9" class="sec">Exec, Fork, Exit and Halt System Calls</a></li>
					<li><a href="#navstage10" class="sec">Exception Handling and Demand Paging</a></li>
					<li><a href="#navstage11" class="sec">Making a console</a></li>
				
				</ol>
			</menu>
		</aside>
		
		<section class="grid col-three-quarters mq2-col-full">
		
			
			
			<div class="grid-wrap">

					
			<article  id="navstage1" class="grid col-full">
			<h2>Stage 1: Setting up the System </h2>

			<p> Follow the instructions in the <a href="usage-spec.html">Usage Documentation</a> to setup the system. The following assumes that the entire package is extracted to $HOME/myxos. If the setting up of the system is done correctly the following directories will be created.
			</p>

			<ul>
				<li> $HOME/myxos/apl <br/>
				This directory contains the compiler required to compile user programs to XSM machine instructions. Try out APL compiler using the instructions given <a href="usage-spec.html#navapl">here</a>.
					<ul> 
						<li> $HOME/myxos/apl/samples - Contains sample APL programs. </li>
						<li> $HOME/myxos/apl_progs - This directory is an empty directory. The user programs written in APL must be saved in this directory.</li>
					</ul>
				</li>
				
				<li> $HOME/myxos/spl <br/>
				This directory contains the compiler required to compile system programs (i.e. operating system routines) to XSM machine instructions. Instructions on how to use SPL compiler is given <a href="usage-spec.html#navspl">here</a>
					<ul>
						<li> $HOME/myxos/spl/samples - 	Contains sample SPL programs </li>
						<li> $HOME/myxos/spl_progs - This directory is an empty directory. The system programs written in SPL must be saved in this directory. The Operating System code written in SPL is to be saved here. </li>
					</ul>
				</li>
				
				<li> $HOME/myxos/xfs-interface <br/>
				This directory contains an interface through which files from linux can be loaded into the File system of XSM (XFS). The interface also provides options for formatting the disk, listing the files loaded into the disk, removing files from the disk, copying continuous blocks from the disk to a file in linux and displaying a file in the disk. Usage instructions and examples can be found <a href="usage-spec.html#navxfs" > here</a>. </li>

				<li> $HOME/myxos/xsm <br/>
				This directory contains the machine simulator. Usage instructions and examples can be found <a href="usage-spec.html#navxsm"> here</a>. </li>

				<li> $HOME/myxos/doc <br/>
				This directory contains the complete specification for <a href="xos-spec.html">XOS</a> (Experimental Operating System), <a href="xsm-spec.html">XSM</a> (Experimental String Machine), <a href="xfs-spec.html">XFS</a> (Experimental File System), <a href="apl-spec.html">APL</a> (Application Programmers Language) and <a hre="spl-spec.html">SPL</a>(System Programmers Language) and <a href="usage-spec.html">Usage Documentation</a> </li>
			</ul>
			</article>

			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	
			
			
			
			
			<article id="navstage2" class="grid col-full">
				<h2>Stage 2: Understanding the Filesystem </h2>
				<p> The first stage of building XOS begins with understanding the underlying <a href="xfs-spec.html">Filesystem (XFS)</a> and its <a href="usage-spec.html#navxfs">interface</a>.  </p>
					<ol>
						<li> Start by formatting the disk in the XFS interface using <b>fdisk</b> command. This can be done by starting the xfs interface
							<div class="syntax">
<pre>cd $HOME/myxos/xfs-interface
./xfs-interface</pre>
							</div> 

						This will take you to the <a href="usage-spec.html#navxfs">xfs-interface</a> prompt. Type the following commands in the xfs-interface prompt
						<div class="syntax"> 
<pre>fdisk 
exit</pre>
						</div>

						You will be back in the linux shell and a file named <b>disk.xfs</b> is created in the location <b>$HOME/myxos/xfs-interface/</b>. This file simulates the hard disk of the machine.</li>

						<li> Create a data file in your UNIX machine.	<br/>	
							A sample data file is given below
								<div class="syntax"> 
<pre>There is a place where the sidewalk ends
And before the street begins,
And there the grass grows soft and white,
And there the sun burns crimson bright,
And there the moon-bird rests from his flight
To cool in the peppermint wind.</pre>
								</div>
								Save the file as <b>$HOME/myxos/sample.dat</b>
						</li>

						<li> Load the data file to the XFS formatted disk from your UNIX machine.  This can be done by 
							<div class="syntax"> 
<pre>cd $HOME/myxos/xfs-interface
./xfs-interface
</pre>
							</div>
							This will take you to the xfs-interface prompt. Type the following commands in the xfs-interface prompt.
							<div class="syntax"> 
<pre>load --data $HOME/myxos/sample.dat</pre>
							</div>
						</li>

						<li> Find out the FAT entry corresponding to the loaded file. See <a href="xfs-spec.h
							tml#navdiskorg">disk organization</a> of XFS Disk. Use the <b>copy</b> command to copy FAT entries (block 10 of the disk) to a file (say <i>fat_block.txt</i>) in your PC as
							<div class="syntax">
<pre>copy 10 10 fat_block.txt
exit</pre>
							</div>
						</li>	
						<li> Check the <a href="xos-spec.html#navfiles_fat">FAT entry</a> by viewing the fat_block.txt 
							file from linux and find the block number of basic block of the loaded data file.
						</li>
						<li>
							Copy the basic block of the file using xfs-interface to a linux file as done above, to get the data blocks used by this file.
						</li>

						<li> Copy the data blocks from the XFS disk and display it as a UNIX file. </li>
			</ol>

			</article>

			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	
			

			<article  id="navstage3" class="grid col-full">
				<h2>Stage 3: Starting the machine </h2>

				<p>When the XSM machine is started up, the <a href="xsm-spec.html#navrom"> ROM Code </a> is executed. The page 0 of the machine is called the ROM Code. It is hard coded into the machine i.e the ROM code at absolute address 0 (to 511) is "already there" when machine starts up. The ROM code is called the "bootstrap" loader in OS literature. ROM code does the following operations :
				<ol>
					<li>Loads block 0 of disk to page 1 of memory (absolute address 512).</li>
					<li>After completing 1, sets IP to 512 so that the next instruction to be exected is fetched from location 512 (page 1 in memory starts from location 512).</li>
				</ol> 
				So if we write a program in SPL, compile it using SPL compiler and load the compiled code to block 0 of disk using xfs-interface, our program will be executed by the machine. This program which we load to block 0 of disk is supposed to be the OS Startup Code. The OS designer must design and program  "OS startup code", compile it using the SPL compiler to generate executable program and copy this program to block 0 of the disk (using xfs interface). Once that is done, this code is loaded into page 1 of memory during boot up by the ROM code. Now your program gets control.</p>
			
				<p>In this stage, we will run a system program to<b> print odd numbers from 1 to n</b> and run it as the OS Startup Code in the machine. The steps to do this are explained in detail below. </p>
				
				<ol>
					<li>Create the program using <a href="spl-spec.html">SPL</a> (System Programmer's Language). It is advised that the system programmer use only the registers R8-R15. <br/>
						SPL Code to print odd numbers from 1 to n (taken as input)
						<div class="syntax"> 
<pre>
alias counter R0;
alias n R1;
print "Enter n:";
read n;
counter = 0;
while(counter <= n) do
	if(counter%2 != 0) then
		print counter;
	endif;
	counter = counter + 1;
endwhile; </pre>
						</div>
					</li>

					<li>Save this file as <b>$HOME/myxos/spl_progs/oddnos.spl</b>. Compile this SPL program using the command
						<div class="syntax">
						<tt> . cd $HOME/myxos/spl </tt><br/>
						<tt> ./spl --os < $HOME/myxos/spl_progs/oddnos.spl  </tt> </div> 
					</li> 

					<li> Load the file generated by the SPL compiler ( <b>$HOME/myxos/spl/os_startup.xsm</b> ) as the OS startup code to <tt>disk.xfs</tt> using the XFS Interface (use the command <b>load --os $HOME/myxos/spl/os_startup.xsm</b> from xfs interface). 
					</li>

					<li> Run the machine using the command 
						<div class="syntax">
. $HOME/myxos/xsm/xsm --disable-timer
						</div>
						<p>The machine has a timer which interrupts the execution at specific intervals and pass the control to timer interrupt routine. We will be dealing with the timer in stage 5 (Interrupts). Until then we will run the machine with the timer disabled.  The <i>--disable-timer</i> is used to disable the timer.</p>
					</li>
				</ol>
				The machine will halt after printing all odd numbers from 1 to n
<pre><tt>
Enter n:
10
1
3
5
7
9
Machine is halting
</tt></pre>

				<p> You may also write a few SPL programs on your own and run it on the machine to get familiarized with SPL syntax. Try using the instructions like <a href="spl-spec.html#navbreakpointstmt"><i>breakpoint</i></a> which translates to <a href="xsm-spec.html#navinstr_brkp">BRKP</a> machine instruction. This instruction is useful for debugging. It displays the contents of all the machine registers at the point where the instruction is used.</p>
			</article>

			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	




			<article  id="navstage4" class="grid col-full">
				<h2>Stage 4: Running a user program </h2>
				<p> User programs or application programs are programmed using <a href="apl-spec.html">APL</a> or Application Programmer's Language. A user program is different from a system program which you run on the machine in stage 3. It is to be noted that a system program is executed in kernel mode ( See <a href="xsm-spec.html#navmodes">Privilege modes</a> ). The machine starts its execution in kernel mode. In kernel mode both privileged and unprivileged instructions can be executed. All memory addresses are absolute addresses in kernel mode. A user program should be run in user mode. In user mode only unprivileged instructions can be executed. Also all memory addresses are logical in user mode. In user mode, the machine translates logical addresses to physical addresses using the <a href="xsm-spec.html#navaddr">address translation</a> scheme of the machine. The OS Startup code must load the user program to be executed from the disk to the memory and set up the page tables so that the address translation scheme works correctly. 
				</p>
				<p>
				Before the start of execution of the application program, the mode of execution must be changed from kernel mode to user mode. The value of Instruction Pointer must be set to the starting logical address of the code of the user program (Since all addresses are logical in user mode, program starts executing from logical address 0). Both switching to user mode and setting of the IP is achieved by using <a href="spl-spec.html#naviretstmt"> ireturn</a> instruction. The ireturn instruction in SPL translates to the machine instruction <a href="xsm-spec.html#navinstr_iret">IRET</a>. </p>
				

				<p>In this stage, an application program in APL is compiled and loaded to the disk as the init process. The first user program which is executed is called the INIT process. INIT program is stored in blocks 13-15 of the XFS disk. It does not have a FAT entry or a basic block. An OS Startup code is written in <a href="spl-spec.html">SPL</a> to load this program to the memory on machine startup.</p>

				<ol>
					<li> Write a program in APL to print all prime numbers lesser than a number taken as input. See <a href="apl-spec.html#navexamples">Examples</a> of APL programs. In the roadmap, the path of the file is assumed to be <tt>$HOME/myxos/apl_progs/prime.apl</tt>. This will be the INIT program for this stage.</li>
					<li> Compile your APL program using the command
						<div class="syntax">
							<tt> cd $HOME/myxos/apl </tt><br/>
							<tt> ./apl < $HOME/myxos/apl_progs/prime.apl  </tt>
						</div> 
						The output file generated is $HOME/myxos/apl/apcode.xsm
					</li>

					<li> Load this file to <b>disk.xfs</b> as <b>INIT program</b> using XFS interface </li>

					<li> Create an SPL program with just a <b>halt;</b> instruction. Here, we have assumed its path to be <b>$HOME/myxos/spl_progs/haltprog.spl</b>.  </li> 

					Compile this program using two different flags as shown
					<div class="syntax">
						cd $HOME/myxos/spl <br/>
						./spl --int=7  < $HOME/myxos/spl_progs/haltprog.spl <br/>
						./spl --exhandler < $HOME/myxos/spl_progs/haltprog.spl 
					</div>
					Now two files named <tt>int7.xsm</tt> and <tt>exhandler.xsm</tt> are created in <tt>$HOME/myxos/spl/</tt> <br/>

					Load these files to the XFS Disk (disk.xfs) using filesystem interface ( Use commands <b>load --int=7 $HOME/myxos/spl/int7.xsm</b>  and <b>load --exhandler $HOME/myxos/spl/exhandler.xsm</b> ) . These files are responsible for halting the machine upon completion of running user program and when an exception occurs respectively. This is to be loaded into the memory by the OS Startup Code. (You will learn about <a href="xos-spec.html#navsysroutines_exhandler">exception handling</a> and <a href="xsm-spec.html#navintrrupt">interrupts</a> in later stages). <br/><br/>
				</ol>

				<h6>OS Startup Code</h6>
				<ol>
					The executable files in <b>INT 7</b>, <b> Exception Handler</b> and the program to print primes  must be loaded to the memory from the XFS disk by the OS Startup Code when the machine starts. The OS Startup Code must be written in <a href="spl-spec.html">SPL</a>, compiled and loaded to the disk as done in the stage 2. The new OS Startup Code must do the following tasks. </br><br/>

					<li> Load Exception Handler from disk block 1 to memory page 7 and INT 7 from disk block 9 to memory page 15 using <a href="spl-spec.html#navlsstmt" >load</a> instruction.
						<div class="syntax">
							load (page_number, block_number);
						</div> 
					</li>

					
					<li>Load the <b>INIT process</b> (program to print primes) from the disk to the memory. In the memory, user programs are stored in pages 16-63. Since INIT is the first process, we will allocate the first 3 pages (pages 16-18) for code. Now the blocks 13-15 from disk are loaded to the memory pages 16-18. </li>
					
					
					<li> The next structure to setup is the INIT's Process Control Block. ( See <a href="xos-spec.html#navpromgmt_pcb">PCB</a> ). The starting address of INIT's PCB is <b>1536</b>. SPL has a <a href="spl-spec.html#navconst">predefined constant</a> <tt>READY_LIST</tt> with this value stored. Setup the PCB with each corresponding entry.
						<ul>
							<li> Set the 1st word with the PID which is 0 for INIT Process </li>
							<div class="syntax">
								[READY_LIST + 0] = 0 // Sets the entry for PID as 0
							</div>
							<li> Similarly, <tt>STATE</tt> of INIT process is set to 2 (running) </li>
							<li> The remaining entries need not be set by the OS startup code. You will learn about these in subsequent stages.  </li>
						</ul> 
					</li> 
					
					
					<li> Setup page tables for the INIT process in the following way. (See <a href="xsm-spec.html#navaddr">Address Translation</a>).
						<ul>
							<li>Set <b>PTBR</b> (Page Table Base Register) to 1024, which is the starting address of process page tables (See <a href="xos-spec.html#navmemorg" >Memory Organization</a>) and <b>PTLR</b> (Page Table Length Register) to 4. This is because a process consists of 4 pages - 3 pages for code and 1 for stack (See <a href="xos-spec.html#navpromgmt_prostruct">Process Structure</a>). Allocate the first page table (address 1024) for the INIT process.</li>

							<li> Each page table entry contains 2 words. Set the first word of each entry to corresponding memory address (16-18) and set the second word (Auxiliary information) as <b>11</b> (Valid and Referenced). Refer <a href="xos-spec.html#navmemmgmt_paging">Paging</a> for the structure of page table entry. </li>

							<li> Setup entries for memory pages 16 to 18 (3 pages are used for code) in the page table as well as one entry for memory page 19 (1 page is used for stack) </li>
							Setting up the entries of page table can be done in the following way
							<div class="syntax">
								[PTBR + 0] = 16;  // Entry for memory address of 1st page<br/>
								[PTBR + 1] = 11;  // Entry for flag<br/>
								.	<br/>
								.	<br/>
								.	<br/>
								[PTBR + 6] = 19;  // Memory address of stack <br/>
								[PTBR + 7] = 11;	<br/>
							</div>
						</ul>
					</li>

					
					

					<li> 
						<p>Next we need to set the stack pointer(SP) and instruction pointer(IP) registers correctly. SP is to be set as <i>3 * 512</i>. This is because once the user program starts to execute all addresses are logical addresses and stack is allocated the logical page 4. <b>IP</b> cannot be explicitly changed by any instruction. When the machine instruction <a href="xsm-spec.html#navinstr_iret"><tt>IRET</tt></a> is executed, first the privilege mode is changed from KERNEL to USER and then the value at the top of the stack is poped out and the <b>IP</b> is set with this value. So to set <b>IP</b> to logical address 0 (code of the user program starts from logical address 0), the value 0 is stored at the top of the stack</p>
						<p>Store 0 in address 19 * 512 ( physical page number 19 * page size 512 is the physical address corresponding to top of the stack). The value 0  will get stored in <b>IP</b> after the control passes to user mode.  <b>IP</b> value is  set to 0 because in user mode, addresses are logical addresses. <b>NOTE: 0 is the starting logical address for IP for any process.</b></p>

						See <a href="xsm-spec.html#navmodes">privilege modes</a> and <a href="xsm-spec.html#navaddr">address translation</a>. 
						<div class="syntax">
							[19*512] = 0;
						</div>
					</li>	

					<li> Set SP to 3 * 512 (logical page number 3 * page size 512).  Before the control passes to the user program, <b>SP</b> (stack pointer) must be set to the logical address of the starting position of the user stack (In this case, INIT process' stack). <b>Why logical address?</b> In user mode all addresses are logical addresses. So before we pass control to user mode, we must set SP to logical address for the machine to work correctly in  user mode. <b>NOTE: 3 * 512 is the starting logical address of SP for any process.</b>
						<div class="syntax">
							SP = 3 * 512;
						</div>
					</li>	

					<li> Use the <b>ireturn</b> instruction to transfer control to user program. This instruction calls the machine instruction  <a href="xsm-spec.html#navinstr_iret">IRET</a> which changes privilege mode from KERNEL to USER (See <a href="xsm-spec.html#navmodes">privilege modes</a>). <tt>IRET</tt> then gets the value stored in memory location pointed to by <b>SP</b> which is 0 (See  step 5) and stores it in <b>IP</b>. The logical address 3*512 stored in SP gets translated to get the actual location of the stack as execution is in USER Mode (See <a href="xsm-spec.html#navaddr">Address Translation</a>). </li> 
				</ol>
			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>



			<article  id="navstage5" class="grid col-full">
			<h2>Stage 5: Interrupts </h2>
			<p> The XSM machine simulator has 7 interrupt routines, a timer interrupt, and an exception handler. Refer <a href ="xsm-spec.html#navintrrupt">Interrupts and Exceptions</a>. The interrupt instructions can be invoked from an application program using system call interfaces. You will be implementing system calls in the subsequent stages.</p>

			In this stage you'll be learning about interrupts. There are two kinds of interrupts - software interrupts and hardware interrupt (timer interrupt). <br/><br/>

			<h5>Implementing a software interrupt</h5>
			<p> Upon encountering the <b>INT</b> machine instruction in a user program, the OS transfers control to the corresponding interrupt service routine. The interrupt service routines reside in pages 9 to 15 of the memory (See <a href="xos-spec.html#navmemorg">Memory Organization</a>). <br/>

			In this stage you'll do a test implementation of an interrupt service routine. Your task is to display "Interrupt Invoked" on an <b>INT</b> instructions. Follow these steps to get this done,</p>

			<ol>
				<li> Create an SPL program to print "Interrupt Invoked". The sample SPL program is given below
					<div class="syntax">
					print "INT";<br/>
					ireturn; </div>
				</li>
				<li> Save this file in your UNIX machine as <b>$HOME/myxos/spl_progs/sample_int.spl</b> </li>
				<li> Compile this program using SPL compiler with the flag --int=1. (We will load this program as Interrupt 1).
					<div class="syntax">
						cd $HOME/myxos/spl<br/>
						./spl --int=1 < $HOME/myxos/spl_progs/sample_int.spl
					</div>
				</li>
				<li> The output file generated will be <b>$HOME/myxos/spl/int1.xsm</b> </li>
				<li> Load this file to the XFS disk as interrupt 1 using xfs-interface. </li>
				<li> Create a user program to invoke INT. We'll program it using XSM Machine instructions for simplicity.
					<div class="syntax">
						START <br/>
						MOV R0, "Before INT" <br/>
						OUT R0 <br/>
						INT 1 <br/>
						MOV R0, "After INT" <br/>
						OUT R0<br/>
						END
					</div>
				</li>
				<li> Load it directly to the XFS disk as <a href="xfs-spec.html#navinit">init program</a>. This program is already in XSM machine code, and hence it need not be compiled.
				</li>
				<li> Modify the OS Startup Code to load the <b>INT 1</b> routine from disk block 3 (See <a href="xfs-spec.html#navdiskorg">Disk Organization</a>) to memory page 9 (See <a href="xos-spec.html#navmemorg">Memory Organization</a>). Add the following line to OS startup code
					<div class="syntax">load (9, 3);</div>
				</li>
				<li> Compile the OS Startup Code using SPL compiler. Load the compiled output file os_startup.xsm to the XFS disk </li>
				<li> Run the machine by disabling the timer.
					<div class="syntax"> $HOME/myxos/xsm/xsm --disable-timer </div>
					You'll get the following output on the screen.
<pre><tt>
Before INT
INT
After INT
Machine is halting
</tt></pre>
				</li>
			</ol>
			<br/>
			<h5>Timer Interrupt</h5>
			<p> The XSM simulator has a timer which invokes the timer interrupt routine after specific number of instructions. In usual machines, the timer interrupt is triggered at specific intervals of time. However in XSM, it is triggered after a specific number of instructions. Refer <a href="xsm-spec.html#navtimer">Timer Interrupt</a>.
			<br/>In this task, we'll create a timer interrupt routine, which prints "TIMER". This can be done in the following steps.</p>

			<ol>
				<li> Create an SPL program to print "TIMER". The sample SPL program is given below
					<div class="syntax">
						print "TIMER";<br/>
						ireturn;
					</div>
				</li>
				<li> Save this file in your UNIX machine as <b>$HOME/myxos/spl_progs/sample_timer.spl</b> </li>
				<li> Compile this program using SPL compiler with the flag --int=timer
					<div class="syntax">
						cd $HOME/myxos/spl<br/>
						./spl --int=timer < $HOME/myxos/spl_progs/sample_timer.spl 
					</div>
				</li>
				<li> The output file generated will be in <b>$HOME/myxos/spl/timer.xsm</b> </li>
				<li> Load this file to XFS disk as Timer Interrupt Routine using xfs-interface.</li>
				<li> Compile the sample program to print numbers upto 20 using APL compiler and load it as the INIT program to XFS disk. The sample program is available at <b>$HOME/myxos/apl/samples/printnum.apl</b> </li>
				<li> Use the same OS Startup Code used previously </li>
				<li> Run the machine this time without disabling the timer, to see the timer interrupt routine in action
					<div class="syntax">. $HOME/myxos/xsm/xsm </div>
					You'll get the following output on the screen with the timer interrupt enabled
<pre><tt>1
2
TIMER
3
4
5
6
7
TIMER
8
9
10
11
12
TIMER
13
14
15
16
17
TIMER
18
19
20
Machine is halting
</tt></pre>
				</li>
			</ol>
			</article>

			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	


			<article  id="navstage6" class="grid col-full">
			<h2>Stage 6: Getting started with Multiprogramming</h2>
			<p> <a href="xos-spec.html#navpromgmt_multiprog">Multiprogramming</a> refers to running more than one process simultaneously. In XSM, the timer interrupt is triggered after a fixed number of instructions are executed in user mode, and the control is passed to Page 8, i.e. the timer interrupt routine. The timer interrupt routine saves the context of the current process in its Process Control Block ( <a href="xos-spec.html#navpromgmt_pcb">PCB</a> ), schedules and dispatches a new program to run on the machine. In this stage we run two programs simultaneously on the machine. The machine is run without disabling the timer. <br/>
			</p>

			In this stage the OS Startup Code loads two programs into the memory and starts the execution of one program. The timer interrupt routine when invoked saves the context of current running process and starts the execution of the other process. <br/>
			The things to be done in this stage are:

			<ol>
				<li> Create 2 user programs in APL
					<ul>
						<li> Write an APL program to print all odd numbers from 1 to 20 and save it as <b>$HOME/myxos/apl_progs/odd.apl</b> </li>
						<li> Compile this program using APL compiler and load the <b>apcode.xsm</b> file generated to the disk using xfs interface as init program. </li>
						<li> Write another APL program to print all even numbers from 1 to 20 and save it as <b>$HOME/myxos/apl_progs/even.apl</b> </li>
						<li> Compile this program using APL compiler and load the <b>apcode.xsm</b> file generated to the disk using xfs interface as an executable file </li>
						<li> Use the xfs interface to find the data blocks to which this file is loaded. This was done in Stage 2. We assume in this roadmap that this file is loaded to blocks 16 - 19, the basic block of the file at block 16 and the data blocks at blocks 17, 18 and 19. Note that this may not be the actual case. </li>
					</ul>
				</li>
				<li> Modify the OS Startup Code <br/>
					The current OS startup code loads only the init process and sets the process structures of only one process (init process). For this stage, it has to be modified to load the second program and set up PCB and page table of this process also. But for the subsequent stages, the current OS Startup code is enough. So before making changes to the current OS Startup Code, take a backup copy of it so that it can be used for the subsequent stages.<br/>
					Before calling ireturn statement in the OS Startup Code do the following:<br/>
					<ul>
						<li> Load the code blocks of the second program from disk (We have assumed that the code blocks are stored in blocks 17 - 19 in the disk) to pages 20 - 22 in memory.
							<div class="syntax">
								load(20,17);<br/>
								load(21,18);<br/>
								load(22,19);<br/>
							</div>
						</li>
						<li> For the second process all the entries in the PCB must be setup. This is because the timer interrupt routine loads the context of this process from its <a href="xos-spec.html#navpromgmt_pcb">PCB</a>. PID field in the PCB of the second process is set to 1 and STATE field is set to 1 (ready) 
							<div class="syntax">
								[READY_LIST + 32] = 1; 		//PID<br/>
								[READY_LIST + 33] = 1;		//STATE<br/>
							</div>
						</li>
						<li> The values for the register SP, BP, IP, PTBR and PTLR are set as: 
							
							<div class="syntax">
								[READY_LIST + 34] = 3 * 512; 	//SP<br/>
								[READY_LIST + 35] = 3 * 512;	//BP<br/>
								[READY_LIST + 36] = 0;			//IP<br/>
								[READY_LIST + 37] = 1024 + 8;	//PTBR<br/>
								[READY_LIST + 38] = 4;			//PTLR<br/>
							</div>
							Stack allocated for the process starts from logical page no 3. So SP and BP fields are set to the start of this page. Code area of the process starts from logical address 0, so IP field is set to zero. The page table of the process should  start from 1024 + PID*8, since page table of each process in our operating system is 8 word long (4 entries each of 2 word size). Field for PTLR is set to 4 since only 4 pages are allocated for the process (3 code pages and a stack page).<br/>
							The rest of the entries of the PCB may not be set now. You will deal with them in subsequent stages.
						</li>
						<li> Add the instruction to load the timer interrupt routine from disk block 2 to memory page 8. 
							<div class="syntax">
								load(8,2);
							</div>
						</li>
					</ul>
				</li>
				<li> Next task to be done in this stage, is to program the Timer Interrupt in SPL, compile it and load it to the disk. <br/>
					The timer interrupt routine must perform the following actions:
					<ul>
						<li> Find the location of the  <a href="xos-spec.html#navpromgmt_pcb">PCB</a> of the current process using the value of PTBR by following these instructions.
						 <ul>
						 <li> We can find the ProcessID of the current process using the PTBR value using this instruction
							<div class="syntax">ProcessID = (PTBR - 1024) / 8;</div>
							Page Tables start at word address 1024. And size of each per-process page table is 8 words. <b>NOTE: This calculation is specific to our operating system. In general Process ID cannot be computed  from the value of PTBR . </b>
						  </li>
						</ul>
						</li>
						<li> The starting address of the ready list of PCBs is 1536. READY_LIST is a predefined constant in SPL which has  value 1536 (ERROR: !!! Refer to memory organization). Size of PCB of each process is 32 words. The starting address of the PCB of the current process can thus be calcluated using this instruction. (ERROR: !!! Alias PCB_Start) 
							<div class="syntax">PCB_Start = READY_LIST + 32 * ProcessID;</div>
						   NOTE: This calculation is specific to our operating system. In general adresss of PCB of current process is not obtained like this.			
						</li>
						<li> Store the values of the current process in its PCB as shown below.
							<div class="syntax">
								[ PCB_Start + 0 ] = ProcessID;		//PID<br/>
								[ PCB_Start + 1 ] = 1; 			// STATE : Waiting for the CPU<br/>
								[ PCB_Start + 2 ] = BP;<br/>
								[ PCB_Start + 3 ] = SP;	<br/>
								[ PCB_Start + 4 ] = [absoluteSP - 1]; 	// IP gets stored in SP by machine<br/>
								[ PCB_Start + 5 ] = PTBR;	<br/>
								[ PCB_Start + 6 ] = PTLR;	<br/>
								[ PCB_Start + 7 ] = R0;	<br/>
								.<br/>
								.<br/>
								[ PCB_Start + 14] = R7;<br/>
							</div>
						</li>
						<li> Scan the Ready List of PCBs in a circular manner from the PCB of current process to check for the next process with STATE 1 (Waiting for the CPU). Store the address of the PCB found in a register.(ERROR !!! Ready List Link) </li>
						<li> Load the fields from this PCB to the corresponding registers. </li>
						<li> Find the physical address of SP corresponding to newly found PCB. (ERROR !!! Explain More + Links) Store IP from this PCB to the location pointed by the physical address of SP. This is to ensure that the IRET sets the IP to its correct value after return from the interrupt. </li>
						<li> Use ireturn instruction to return to USER Mode </li>
					</ul>
				</li>
				<li> Compile the OS Startup Code and Timer interrupt using the SPL Compiler. </li>
				<li> Load the new OS Startup code and timer interrupt routine to the xfs disk using xfs interface. </li>
				<li> Run the machine without disabling timer </li>
				
			</ol>
			The programs will run in an interleaved fashion if the timer interrupt is working correctly.


			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>


			<article id="navstage7" class="grid col-full">
				<h2>Stage 7: Creating Files </h2>
				<p> In this stage, you'll learn to implement a <a href="xos-spec.htmlnavsyscalls"> system call </a>. System calls are interfaces provided by the operating system to the user programs to run a system routine. The system calls in XOS are invoked  using commands in SPL which will call a specific INT instruction. The (ERROR !!! INT) instruction invokes an interrupt service routine, as done in stage 5.

				 In this stage we'll modify the Interrupt 1 routine to implement the funtionality to create files in the XFS disk. Interrupt 1 is used by two system calls Create and Delete. (See <a href="xos-spec.html#navsyscalls_file">File System Calls</a>).


				<h6> Modifying the OS Startup Code</h6>
				(ERROR !!! Uniprocessing mode, we'll disable timer till then) Modify the OS Startup Code in Stage 5. The OS Startup Code modifications done in Stage 6 can be discarded as it was done to test the timer interrupt routine.
				<ol>
				<li> Load FAT from disk block 10 to memory page 5 and Disk Free List from the disk block 11 to memory page 6. Refer <a href="xos-spec.html#navmemorg">Memory Organization</a> and <a href="xfs-spec.html#navdiskorg">Disk Organization </a>. </li>
				</li>
				<li>
				Set the FAT Entry and File Open Count of 64 entries of the  <a href="xos-spec.html#navfiles_swoft">System-Wide Open File Table</a>  to -1. 

			</li>
				<div class="syntax">
				<pre>
alias counter R8;	// R8 - R15 is used by system programmers.
counter = 0;
while ( counter <=  128) do
	[ FILE_TABLE + counter] = -1;
	counter = counter + 1;
endwhile;						</pre>
				</div>
				<li> Set all words in the <a href="xos-spec.html#navpromgmt_pcb">Per-Process Open-File Table in the PCB</a> of INIT to -1  (ERROR !!! Why) </li>
				<li> You've already written code to load Interrupt routine 1 from the disk to the memory in stage 5.
					Check if this instruction is present in the OS Startup Code. 
					<div class="syntax">load (9, 3);</div>
					This instruction loads disk block 3 (containing interrupt 1 routine) to memory page 9 (See <a href="xos-spec.html#navmemorg" >Memory Organization</a>). 
				</li>
				</ol>
				A user program  invokes a system call by first pushing the registers, arguments and system call number into the stack and then invoking <tt> INT </tt> instruction corresponding to the system call. 

				 <img src="doc/syscallstack.png" style="width:150%">
				<br/>
				This figure shows the contents of the stack before a system call is exectued and after it comes back to the user program. A system call in an APL program compiles to a set of instructions for setting up the stack (Figure a. Step 1) followed by the corresponding INT instruction (Figure a. Step 2). The INT instruction passes control to the corresponding Interrupt routine. In the case of <b>Create</b> it corresponds Interrupt Routine 1.  After the interrupt routine performs the required actions, it passes control back to the user program (Figure b. Step 1 and 2). 

				<br/><br/>
				An Interrupt  Routine may contain more than one system call implementation. The system call number is obtained from the stack (Stack Pointer - 1). Based on the system call number, the corresponding system call actions are performed. To access the stack in KERNEL mode, the physical address of the top of the stack must used. The physical address of the top of stack is calculated as: (ERROR !!! EXPLAIN MORE AFTER THIS) The 6th word in the Page Table (obtained from PTBR + 6) gives the starting address of the stack, and SP%512 will give the offset in the stack. Adding both will give the absoulte address of SP. 
				<br/><br/>

				<br/>
				A skeleton of Interrupt 1 Routine is given below.

				<div class="syntax">
				<pre>
alias absoluteSP R8;
absoluteSP = [PTBR + 6] + SP % 512 ;
.
// Get system call no. from the stack
.
if ( sysCallNo == 1) then
	// Implementation of Create (to be done in this stage !)
	.
	.
endif;
if ( sysCallNo == 4) then
	// Implementation of Delete
	.
	.
endif;	</pre>
				</div>

				In this stage we'll implement the Create System Call. Delete and other system calls will be implemented in later stages.
				(ERROR !!! Give an Overview)



				<ol>
				<li> (ERROR !!! Look for a free entry in DFL from 13 to 447) First of all, the memory copy of the <a href="xfs-spec.html#navdfl">disk free list</a> is searched till the entry for block number 447 to find a free block number (indicated by a 0 entry in the disk free list). Blocks 448 - 511  are reserved for <a href="xfs-spec.html#navdiskorg">swap area</a> which will be used for virtual memory management (<a href="roadmap.html#navstage9">Stage 9</a>). (ERROR !!! about 0 - 12) This block is used as the <a href="xfs-spec.html#navfile">basic block</a> of the file to be created. It's entry is set to 1. The block number is stored to a register. If no free block is found return -1 (as done in the previous step). </li>

				<li> The <tt>filename</tt> specified as argument is stored in the stack at (ERROR !!! ) absoluteSP - 2. Fetch it and store it to a register. </li>
				<li> The memory copy of the <a href="xos-spec.html#navfiles_fat">FAT</a> is to be searched for the <tt>filename</tt> to check if the file already exists. If it exists return from the sytem call with 0 (success).
				</li>

				<li> Next, the memory copy of the <a href="xos-spec.html#navfiles_fat">FAT</a> is searched for a free entry. A free entry in the FAT is indicated by -1 in the entry for basic block (Word 2 of each FAT entry). If no free entry is found put -1 in the return value space of the stack (absoluteSP - 12, See figure above). Then return to USER Mode using <b>ireturn</b> instruction. Address of FAT is stored in a <a href="spl-spec.html#navconst">predefined constant</a> in <tt>FAT</tt> in SPL. </li>
				<li><tt>filename</tt> and the <tt>free block number</tt> obtained  in the previous steps are stored in the <em>Filename</em> field and <em>basic block number</em> field of the free <a href="xos-spec.html#navfiles_fat">FAT</a> entry respectively.</li> (ERROR !!! BASIC BLOCK)
					<li> The <em>file size</em> field of the FAT entry is initialized to zero.</li>

(ERROR !!! Explain why the code is here!!)
				<div class="syntax">
						<pre>
alias counter R8;
counter = 0;
while(counter < 512) do
	if([FAT + counter + 2] == -1) then
		.
		// Set the FAT entry 
		.
		break;
	endif;
	counter = counter + 8;
endwhile;

// Return with -1 if there is no free entry
if(counter == 512) then 		
	[absoluteSP - 12] = -1;		
	ireturn;	
endif;</pre>
				</div>
		
				<li> Load the <a href="xfs-spec.html#navfile">basic block</a> of the file from the disk to the <a href="xos-spec.html#navfiles_scratchpad">scratchpad</a> . Each entry of the block list in the basic block is initialized to zero and it is stored back to the disk.</li>	
				<li> The updated copies of FAT and disk free list in the memory are then stored back to the disk.</li>
				
				<li> The return value of this system call is 0 in case of success and -1 in case of failure. The return value is stored in the stack at address Stack Pointer - 12. The value of stack pointer is obtained from absoluteSP.</li>
				<li>Use an <b>ireturn</b> instruction to transfer control back to USER Mode.</li>
				</ol>
			
			Check if the file is created by using the ls command in the XFS interface.


			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>



			<article  id="navstage8" class="grid col-full">
			<h2>Stage 8: Playing with files</h2>
			<p>We have already created files using the "Create" system call. Now we will implement the remaining 
			system calls - <b>Open, Close, Delete, Write, Seek and Read</b>.</p>
				
				<h4>File System Calls</h4>
				<table class="doctable" style="width:50%">
					<tr><th>System Call Name</th><th>System Call #</th><th>Interrupt Routine #</th></tr>
					<tr><td>Create</td>			 <td>1</td>				<td> 1</td> </tr>
					<tr><td>Open</td>			<td>2</td>				<td> 2</td> </tr>
					<tr><td>Close</td>			<td>3</td>				<td> 2</td> </tr>
					<tr><td>Delete</td>			<td>4</td>				<td> 1</td> </tr>
					<tr><td>Write</td>			<td>5</td>				<td> 4</td> </tr>
					<tr><td>Seek</td>			<td>6</td>				<td> 3</td> </tr>
					<tr><td>Read</td>			<td>7</td>				<td> 3</td> </tr>
				</table>

			<h6> Open </h6>
			<i>System Call No</i>: 2 <br/>
			<i>Interrupt Routine No</i>: 2 <br/>
			<i>Arguments</i>: filename <br/>
			<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
			<br/>
			Opens a file with the filename given as argument.

			<ol>
				<li> Memory copy of FAT is searched for the <tt>filename</tt> (get the <tt>filename</tt> from stack as explained in the Create system call) . If the entry is not found, -1 is returned. Otherwise, store the index of the FAT entry in a register.</li>

				<li>Then, the <a href="xos-spec.html#navfiles_swoft">System-Wide Open File Table</a> is searched for the FAT Index  found in the previous step. If an entry is found, increment the <a href="xos-spec.html#navfiles_swoft"><tt>File Open Count</tt></a>.</li>

				<li> If an entry is not found with the FAT Index, then search for a free entry in the System-Wide Open File Table. If there are no free entries (indicated by -1 <tt>FAT Index</tt> field), return from the system call with return value -1. Otherwise, store <tt>FAT Index</tt> and set the <tt>File Open Count</tt> field as 1 in free entry found.	</li>

				<li> Store the index of the entry (in System-Wide Open File Table) in a register.</li>

				<li> Every process will have a <a href="xos-spec.html#navpromgmt_pcb">Per-Process File Table</a> in its PCB. This stores the details of files opened by this process. Find the PCB's location using the value of PTBR (It may be directly obtained if there is only one process, however following a general approach to get PCBs will be useful when more than one process starts running). Recall that using the value of PTBR we can find the ProcessID using the formula.
					
					<div class="syntax"><tt>  ProcessID = (PTBR - 1024) / 8; </tt></div>
				
				Page Tables start at word address 1024. And size of each <a href="xos-spec.html#navpromgpmt_pagetbl">per-process page table</a> is 8 words. <b>NOTE: This calculation is specific to our operating system. In general Process ID is not obtained from the value of PTBR.</b> 
				<br/><br/>
					We can find the PCB of the current process using the <tt>ProcessID</tt> as done in earlier stages.

					<div class="syntax"><tt> PCB_Start = READY_LIST + 32 * ProcessID; </tt></div>
					
					
				</li>

				<li>  A free entry is searched in the <a href="xos-spec.html#navpromgmt_pcb">per-process open file table in the PCB</a> of the process. A free entry is indicated by -1 in the first field (Pointer to <a href="xos-spec.html#navfiles_swoft">System-Wide Open File Table</a>). If there are no free entries, -1 is returned by the system call. </li>

				<li> Otherwise, set the <tt>Pointer to System-Wide File Table Entry</tt> field to the index stored in Step 4 and set <tt>LSEEK Position</tt> to 0.  </li>
			
				<li> The index of this entry in the local file table is returned as a return value of the system call. This is known as the file descriptor.</li>
			</ol>


			<h6> Close </h6>
			<i>System Call No</i>: 3 <br/>
			<i>Interrupt Routine No</i>: 2 <br/>
			<i>Arguments</i>: fileDescriptor <br/>
			<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
			<br/>
			Closes a file opened by the process.

			<ol> 
				<li> Get the address of PCB of the process as in the Open System Call implementation.</li>
				<li> Index into the per-process open file table using the argument <tt>fileDescriptor</tt>. Return from the system call with -1 (failure) if the <tt>fileDescriptor</tt> is invalid or its corresponding entry is invalid.</li>
				<li> Using the <tt>Pointer to System Wide Open File Table Entry</tt> field, index to the System Wide Open File Table </tt> and decrement <tt>File Open Count</tt> by one. If it becomes 0, invalidate the entry by setting both the fields to -1. </li>
				<li> Now invalidate the Per-Process Open File Table entry, by setting the fields to -1</li>
				<li> Return from system call with 0 (success).
				 </li>
			</ol>

			<h6> Delete</h6>
			<i>System Call No</i>: 4 <br/>
			<i>Interrupt Routine No</i>: 1 <br/>
			<i>Arguments</i>: filename <br/>
			<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
			<br/>
			Deletes a file in the disk with the filename given as argument.


			<ol>
				<li> Search the memory copy of <a href="xos-spec.html#navfiles_fat">FAT</a> for the <tt>filename</tt> specified as argument. If it is not found, return from the system call with -1 (failure). </li>
				<li> If an entry is found, store the index in a register. </li>
				<li> Search the System Wide Open File Table to see if the file has been opened. If it is opened, return from the system call with -1 (failure) </li>
				<li> Otherwise, follow the steps to invalidate and delete the file <li>
					<ul>
					<li>Load the <a href="xfs-spec.html#navfile"><tt>Basic Block</tt></a> to the <a href="xos-spec.html#navfiles_scratchpad">Scratchpad</a>. </li>
					<li> For each block used by the file (specified in the Basic Block), invalidate the corresponding block's entry (Setting -1) in the memory copy of the <a href="xfs-spec.html#navdf">Disk Free List</a></li>
					<li> Invalidate the entry for the basic block in the Disk Free List by setting -1.</li>
					<li> Invalidate the <a href="xos-spec.html#navfiles_fat">FAT</a> entry by setting -1 in the <tt>Block # of Basic Block</tt> field.</li>
					</ul>
				<li> Store back  the FAT and Disk Free List from the memory to the disk.</li>
				<li> Return from the system call with 0 (success)</li>
			</ol>

			<h6> Write </h6>	
			<i>System Call No</i>: 5 <br/>
			<i>Interrupt Routine No</i>: 4 <br/>
			<i>Arguments</i>: 1) fileDescriptor 2) wordToWrite <br/>
			<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
			<br/>
			Writes a word specified by <tt>wordToWrite</tt> to a file opened by the process.

		  	<ol>
		  		<li> Get the arguments to registers from the stack </li>
				<li> Get the address of PCB of the process. </li>
				<li> Index into the per-process open file table using <tt>fileDescriptor</tt>. Return from the system call with -1 (failure) if the <tt>fileDescriptor</tt> is invalid or its corresponding entry is invalid.</li>
				<li> Otherwise, store the LSEEK position to a register.</li>
				<li> Using the <tt>Pointer to System Wide Open File Table Entry</tt> field, index to the System Wide Open File Table to get the FAT Index Entry.   </li>
				<li> Fetch the <tt>basic block</tt> from the FAT and load it to the scratchpad</li>
				<li> Using LSEEK position find the block number to be written to. Find its location in the disk from the basic block. If entry for the block is invalid, then allocate a new block in the following way.</li>
					<ul>
						<li> Traverse through the memory copy of the <a href="xfs-spec.html#navdfl">Disk Free List</a> till the entry for block 447 to get a free block.
						<li> If no free block is avaliable. Return from the system call, with return value -1 (failure). </li>
						<li> Otherwise, set 1 in the entry for the  free block in the Disk Free List. Update the basic block with this block number. </li> 
						<li> Commit the basic block from scratchpad back to the disk. </li>
						<li> Increment the <tt>file size</tt> in the FAT entry by 1. </li>
						<li> Commit the FAT and Disk Free List from the memory to the disk. </li>
					</ul>
				<li> Fetch this block from the disk to the scratchpad. </li>
				<li> Write the argument <tt>wordToWrite</tt> to this block using the offset calculated using LSEEK position.</li>
				<li> Commit this block back to disk </li>
				<li> Increment LSEEK Position by 1 in the Per-Process Open File Table </li>
				<li> Return from the system call with 0 (success)</li>
		  	</ol>


		  	<h6> Seek </h6>
			<i>System Call No</i>: 6 <br/>
			<i>Interrupt Routine No</i>: 3 <br/>
			<i>Arguments</i>: 1) fileDescripto	r 2) newLseek <br/>
			<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
			<br/>
			Changes the value of LSEEK position of the file to <i>newLseek</i>.

		  	<ol>
		  		<li> Get the arguments to registers from the stack </li>
		  		<li> Get the address of PCB of the process. </li>
				<li> Index into the per-process open file table using <tt>fileDescriptor</tt>. Return from the system call with -1 (failure) if the <tt>fileDescriptor</tt> is invalid or its corresponding entry is invalid.</li>
				<li> Using the <tt>Pointer to System Wide Open File Table Entry</tt> field, index to the System Wide Open File Table to get the FAT Index Entry.   </li>
				<li> Fetch the <tt>file size</tt> of the file from the FAT and store it in a register. </li>
				<li> If value of the argument <tt>newLseek</tt> is between 0 and <tt>file size * block size</tt>, change the <tt>LSEEK</tt>  in the per-process file table to <tt>newLseek</tt>. Return with 0 (indicating success).</li>
				<li> Otherwise, return with -1 (indicating failure). </li>
		  	</ol>

		  	<h6>Read</h6>
			<i>System Call No</i>: 7 <br/>
			<i>Interrupt Routine No</i>: 3 <br/>
			<i>Arguments</i>: 1) fileDescriptor 2) Variable<br/>
			<i>Return Value</i>: 0 (success) and -1 (failure) </br>
			<br/>
			Reads a word from a file to the variable passed as argument

		  	<ol>
		  		<li> Get the arguments to registers from the stack </li>
				<li> Get the address of PCB of the process. </li>
				<li> Index into the per-process open file table using <tt>fileDescriptor</tt>. Return from the system call with -1 (failure) if the <tt>fileDescriptor</tt> is invalid or its corresponding entry is invalid.</li>
				<li> Otherwise, store the LSEEK position to a register.</li>
				<li> Using the <tt>Pointer to System Wide Open File Table Entry</tt> field, index to the System Wide Open File Table to get the FAT Index Entry.   </li>
				<li> Fetch the <tt>basic block</tt> from the FAT and load it to the scratchpad
				</li>
				<li> Using LSEEK position find the block number to be read from. Find its location in the disk from the basic block. If entry for the block is invalid, return with value -1 (indicating failure).</li>
				<li> Else,  fetch this block from the disk to the scratchpad. </li>
				<li> Read from this block using the offset calculated using LSEEK position. </li>
				<li> This value is stored in the stack in position of Argument 2. Store the word read to absoluteSP - 2.</li>
				<li> Return with 0, indicating success </li>
		  	</ol>

			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	
			
			
			
			<article  id="navstage9" class="grid col-full">
			<h2>Stage 9: Exec, Fork, Exit and Halt System Calls</h2>
			<p>  
			There are several process system calls which are used to create processes, load a new process to an existing process, exit from a process and halt the machine. These system calls are <b>Exec, Fork, Exit and Halt</b>.</p>
			<br/>

			 <h5>Fork system call :</h5>
			 The<a href="xos-spec.html#navsyscalls_process"> Fork </a> system call is used to replicate the process which invoked this system call in the memory. <br/>
			 <i>System Call No</i>: 8 <br/>
			<i>Interrupt Routine No</i>: 5 <br/>
			<i>Arguments</i>: None<br/>
			<i>Return Value</i>: PID of the process created (success) or -1 (failure)</br>

			</br>
			Interrupt 5 Routine must be programmed in SPL, compiled and loaded to disk. It must perform the following tasks.
		  	<ol>
			<li> The <em>Ready list</em> of PCBs is traversed to find a PCB with State 0 (terminated).</li>
			<li> If no such PCB is found, -1 is returned. </li>
			<li> The index of the PCB in the Ready List is the PID of new process created. It is stored in a register.</li>
			<li> The pages used by the parent process is replicated in the following way</li>
				<ul>
					<li> The page table of the parent process is checked to count the number of valid pages. The <a href="xos-spec.html#navmemmgmt_mfl">memory free list</a> is checked to find an equal number of free pages. If this check fails, return with -1 indicating failure. </li> 
					<li> Otherwise an equal number of pages are allocated by updating the memory free list.</li>
					<li> Make corresponding entries in the child process' page table. The child's PTBR (address of its page table) is computed using PID stored in Step 3 </li>
				</ul>
			<li> The current register values of the parent process are (except PTBR)  copied to the child process' PCB. The entry for PTBR is the child's PTBR computed in the previous step. (<b>DO NOT</b> copy values from parent's PCB to child's PCB as it may not be equal to current values) </li>

			<li> The Per-Process Open File table of the parent process is not copied to child's PCB. Instead invalidate all entries in child's Per-Process Open File Table </li>
			<li> Control is passed back to the parent process using <b>ireturn</b>.</b>
		  	</ol>
		  	<b> OS Startup Code</b> is modified to 
		  		<ul>
		  			<li>Load Interrupt 5 Routine. (The code to load the 2nd process in the previous stage can now be removed)
		  			</li> 
		  			<li> The entries for pages 0 to 15 in the <a href="xos-spec.html#navmemmgmt_mfl">memory free list</a> is marked as used (set 1) and others as unused (set 0). Pages 0 - 15 are reserved for OS structures. See <a href="xos-spec.html#navmemorg"> Memory Organization </a>
		  			</li> 
		  		</ul>
		  	To test Fork(), use Exec with program to print odd numbers after issuing a Fork from the INIT program (to print even numbers). 
			
			</br><br/></br>
			<h5>Exec system call :</h5>
			The <a href="xos-spec.html#navsyscalls_process">Exec </a>system call is used to load and run a new process from a currently running process. The current process is overwritten by new process i.e. the process data structures of the current process is used by the new process. </br>
			<i>System Call No</i>: 9 <br/>
			<i>Interrupt Routine No</i>: 6 <br/>
			<i>Arguments</i>: filename <br/>
			<i>Return Value</i>: 0 (success) and -1 (failure) </br>
		
			 <br/>
			 The Interrupt 6 Routine is to be programmed in SPL, compiled and loaded to the disk. 
			 <b>OS Startup Code</b> is modified to load Interrupt Routine 6 from the disk to memory. </br>

			 The Interrupt 6 Routine performs the following actions.
			 <ol>
		 		<li> Get the filename to a register from the stack </li>
		 		<li> Search for the filename in the memory copy of FAT. If it doesn't exist return -1 (indicating failure). </li>
		 		<li> Otherwise fetch the basic block (location is obtained from FAT) and place it in the <a href="xos-spec.html#navfiles_scratchpad">scratchpad</a>.
		 		</li>
		 		<li> Load the blocks of the file (a maximum of 3 blocks) to the memory in pages of the current process.</li>
		 		<li> Close all files opened by the current process by following the steps in <b>Close()</b> system call </li>
		 		<li> SP is reset to 3*512.  </li>
		 		<li> 0 is stored in 19*512 (physical address of the stack) to set IP by the <b>ireturn</b> instruction </li> 
				<li> Return from the system call with 0 (indicating success).</li>
			 </ol>

			 <b>Exec</b> system call can be tested out by modifying the INIT program, by adding an <a href="apl-spec.html#navexec">Exec</a> call in it. 
	</br>	</br><br/>

			<h5>Exit system call :</h5>
			This system call is used to terminate the execution of the process which invoked it. Exit removes this process from the memory. If there is only one process, it halts the system.<br/>
			<i>System Call No</i>: 10 <br/>
			<i>Interrupt Routine No</i>: 7 <br/>
			<i>Arguments</i>: None<br/>
			<i>Return Value</i>:-1 on failure, exits on success </br>
			

		</br>	</br>
			<h5>Halt system call :</h5>
			<i>System Call No</i>: 0 <br/>
			<i>Interrupt Routine No</i>: 7 <br/>
			<i>Arguments</i>: None<br/>
			<i>Return Value</i>:-1 on failure, halts on success </br>
			If there is only one process in memory, it halts the system. Otherwise returns -1.
			<br/><br/>
			Both Exit and Halt are implemented in Interrupt 7 Routine. It is to be programmed in SPL, compiled and loaded to the disk using XFS Interface. It does the following tasks 
				<ol>
					<li> If there is only one process, halt the system using <tt>HALT</tt> instruction irrespective of the system call </li>
					<li> If its Exit system call, do the following actions</li>
						<ol style="list-style-type:lower-roman;">
							<li> Find the PCB of the current process using PTBR 
							</li>
							<li> Close all files opened by the process as done for <b>Close</b> system call</li>
							<li> Set the STATE in the PCB to 0.  </li>
							<li> Invalidate all entries in its per-process page table (Set <tt>Address</tt> field to -1) </li>
							<li> Find the next waiting process from the  <a href="xos-spec.html#navpromgmt_readylist">Ready List of PCBs</a></li>
							<li> Get the IP from its PCB and store it in its stack (Compute absolute address of its SP)</li>
							<li> And use <b>ireturn</b> instruction to transfer control.</li>
						</ol>
					<li> Otherwise, exit with -1 </li>	

				</ol>
	 		<b>OS Startup Code</b> is modified to load Interrpt 7 from disk to memory. 

			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>
			
			
			<article  id="navstage10" class="grid col-full">
			<h2>Stage 10: Exception Handling and Demand Paging</h2>
			<p> 
				<a href="xos-spec.html#navsysroutines_exhandler">Exception Handler</a> in XOS handles exceptions caused by machine. When an exception occurs, the machine sets the <tt>EFR</tt> (Exception Flag Register) and calls the Exception Handler in Page 7. You must read about <a href="xsm-spec.html#navexcep">Exceptions</a> before proceeding .
			</p>


			This stage involves programming the Exception handler in SPL, compiling and loading it to disk. The OS Startup Code must be modified to load the exception handler from disk to memory on startup. 

			The exception handler must do the following :
			<ol>
				<li> The details corresponding to the exception is stored in EFR register. The individual values in EFR must be extracted to registers. 
					<div class="syntax">
						<pre>
Cause = EFR % 10;		// Gets value of cause field (size 1 char)
VPagenum = (EFR / 10) % 100;    // Gets value of BadVAddr 
Ip_addr = (EFR/1000);		//Gets value of IP at the point of exception
</pre>
						
					</div>
				</li> 
				<li> 
					If <tt>Cause</tt> is a value other than 0, Display the error and exit the process which caused the exception. The process can be identified by the current <tt>PTBR</tt> value. Follow the steps done in Exit system call implementation. 
				</li>
				<li>
					If <tt>Cause</tt> it is 0 (Page Fault), the following actions have to be performed.
					<ol style="list-style-type:lower-roman">

						<li> Allocate a free page by searching through the memory free list. If a free page is not found, follow the page replacement technique, described later to find a free page. Store its page number in a register </li>
						<li> Get the <tt>physical page number</tt> field corresponding to <tt>VPagenum</tt> from the Per-Process page table of process that caused the exception.  </li>
						<li> If the <tt>physical page number</tt> field of the <a href="xos-spec.html#navpromgmt_page">Per-Process Page Table</a> is a disk block number, load the disk block to the free page allocated in Step i. Otherwise, this step can be omitted. </li>
						<li> Set the Per-Process Page Table entry corresponding to  <tt>VPagenum</tt> with the page number of free page and set the <tt>Auxiliary flag</tt> as 11. (Valid and Referenced) </li>
						<li> Put Ip_addr to the memory location pointed to by the physical address of SP. </li>
						<li> Return to USER Mode using <b>ireturn</b> instruction. </li>
					</ol>
				</li>
				<br/>
			</ol>
				<h6>Page-Replacement Algorithm</h6>
				<p>The page replacement technique used in XOS is a <i>Second Chance Algorithm</i> which uses the <i>reference bits</i> in the auxiliary information. The steps are as follows
					<ol>
						<li>
						It scans the valid entries in the  Per-Process Page Tables of all processes in a circluar fashion and checks for a page with reference bit '0'.
						</li>
						<li>
						The scanning starts from the current page table entry which issued a page fault.
						</li>
						<li> Whenever a page with reference bit '1' is encountered it is set to '0' and goes to the next page, giving a referenced page a second chance. </li>
						<li> When a page with reference bit '0' is encountered it is selected as the victim page. Then </li>
							<ol style="list-style-type:lower-roman">
								<li>  Memory copy of Disk Free List is scanned for a free block in the swap area (blocks 448 - 511). </li>
								<li> If no free block is found the corresponding process will be terminated	</li>
								<li> If a free block is found, the victim page is stored on that block and memory copy of Disk Free List is updated. </li>
								<li>The entry for the victim page in the Per-Process Page Table is updated with the address of this block and is set as invalid. </li>
							</ol>

			</ol>
			<h6>Modifications to OS Startup Code and Exec system calls</h6>
			When a process is loaded, only the disk addresses of the corresponding code blocks needs to be set in the page table and its <tt>Auxiliary Information</tt> is set to 00 (Invalid and Unreferenced). Put the <tt>Physical Address</tt> field of remaining entries are set to -1 with  <tt>Auxiliary Information</tt>  as "00". The disk blocks need not be loaded initially. It will be loaded by <a href="xos-spec.html#nnavmemmgmt_vm">pure demand paging strategy</a> when required.
			<br/>
			<h6> Modifications to Fork </h6>
			For Fork system call, when it copies the address space, duplicate all valid addresses as done earlier. If the entry in the page table of the parent process is invalid, 
				<ul>
					<li>
						If it is a disk address less than 448 (not swap area), copy the entry directly to the page table of the child.
					</li>
					<li>
						If it is a disk address >= 448 (swap area), check the disk free list and get a free swap block. Copy the contents of current swap block to the newly allocated swap block by using scratchpad. Set the page table of the child with the newly allocated swap block number and copy the <tt>Auxiliary Information</tt> from the parent's page table entry. 
					</li>
					<li>
						If the address is -1, do nothing.
					</li>
				</ul>


			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>


			<article  id="navstage11" class="grid col-full">
			<h2>Stage 11: Making a console </h2>
			<p> 
				The final stage is to make the INIT  process act like a console. INIT written in APL, should be an infinite loop, which takes in  filenames. This filename should correspond to the program to be executed.
				It should <a href="apl-spec.html#navfork"><b>Fork</b></a> itself and <a href="apl-spec.html#navexec"><b>Exec</b></a> using the filename. Appropriate errors must be reported. 
			 </p>

			
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>
			 <br/><br/>
 			<center><h6>AND THAT'S YOUR OWN </h6><img src="img/logo-img.jpeg" style="margin:0;  width:40px"></center>
			</article>
							
							
			
		</div> <!-- 100%articles-->

		
		</section>	
		
		
		
	</div> <!--main-->
<div class="divide-top">
	<footer class="grid-wrap">
		<ul class="grid col-one-third social">
			<li><a href="http://github.com/XOS-NITC">Github</a></li>
		</ul>
	
		<div class="up grid col-one-third ">
			<a href="#navtop" title="Go back up">&uarr;</a>
		</div>
		
		<nav class="grid col-one-third ">
			<ul><li><a href="index.html" >Home</a></li>
				<li><a href="about.html">About</a></li>
				<li><a href="documentation.html">Documentation</a></li>
				<li><a href="downloads.html">Downloads</a></li>
				<li><a href="roadmap.html">Roadmap</a></li></ul>
			</ul>
		</nav>
	</footer>
</div>
</div>

<!-- Javascript - jQuery 
<script src="http://code.jquery.com/jquery.min.js"></script>-->
<script src="js/jquery-1.7.2.min.js"></script>
<script>window.jQuery || document.write('<script src="js/jquery-1.7.2.min.js"><\/script>')</script>

<!--[if (gte IE 6)&(lte IE 8)]>
<script src="js/selectivizr.js"></script>
<![endif]-->

<script src="js/scripts.js"></script>

<!-- Asynchronous Google Analytics snippet. Change UA-XXXXX-X to be your site's ID. -->
<script>
  var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
</body>
</html>

