<!DOCTYPE html>

<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js lt-ie9 lt-ie8" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js lt-ie9" lang="en"> <![endif]-->

<!--[if gt IE 8]><!--> <html class="no-js" lang="en"> <!--<![endif]-->

<head>
	<meta charset="UTF-8">
	
	<!-- Remove this line if you use the .htaccess -->
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

	<meta name="viewport" content="width=device-width">
	
	<meta name="description" content="Build a simple opearting system">
	
	<title>Runtime Environment // Documentation // eXperimental Operating System</title>
	
	<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
	<link rel="shortcut icon" type="image/png" href="favicon.png">
	

	<link rel="stylesheet" href="css/style.css">
	
	<!--[if lt IE 9]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
</head>



<body>
<!-- Prompt IE 7 users to install Chrome Frame -->
<!--[if lt IE 8]><p class=chromeframe>Your browser is <em>ancient!</em> <a href="http://browsehappy.com/">Upgrade to a different browser</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to experience this site.</p><![endif]-->

<div class="container">

	<header id="navtop">
		<a href="index.html" class="logo fleft">
			<img src="img/logo.png" alt="XOS">
		</a>
		
		<nav class="fright">
			<ul><li><a href="index.html" >Home</a></li>
				<li><a href="about.html">About</a></li>
				<li><a href="documentation.html" class="navactive">Documentation</a></li>
				<li><a href="downloads.html">Downloads</a></li>
				<li><a href="roadmap.html">Roadmap</a></li></ul>
			</ul>
		</nav>
	</header>


	<div class="services-page main grid-wrap">

		<header class="grid col-full">
			<hr>
			<p class="fleft">Runtime Environment</p> <br/><br/>
					<!-- <a href="doc/usage.pdf" class="button"> Download as PDF </a> -->
		</header>


		<aside class="grid col-one-quarter mq2-col-full">
		
			<menu>
				<ul>

					<li><a href="#navintro" class="sec" >Introduction</a></li>
					<li><a href="#navmachineview" class="sec" > Machine view of a process</a></li>
						<li><a href="#navmemory" class="subsec" > Memory</a></li>
						<li><a href="#navregisters" class="subsec" > Registers</a></li>
						<li><a href="#navinstr" class="subsec" > Instructions</a></li>
					<li><a href="#navtranslate" class="sec" >Translating APL Programs</a></li>
					<li><a href="#navfncalls" class="subsec" >Function calls in APL</a></li>
					<li><a href="#navsyscalls" class="subsec" >System calls in APL</a></li>
		
				</ul>
			</menu>
		</aside>
		
		<section class="grid col-three-quarters mq2-col-full">
		
			
			
			<div class="grid-wrap">
			<article  id="navintro" class="grid col-full">
				<h2>Introduction</h2>
				<p>  Runtime Environment of a process refers to execution environment provided to the process by the operating system. The runtime environment dictates how executable code is loaded into memory, where data is stored, and how function calls and system calls take place. </p>

				<p> A user program in execution is termed as a process. User programs are written in APL, which is a high level language. When an APL program is compiled, it generates XSM machine instructions. These machine instructions are unprivileged instructions and will be run in the USER mode (See <a href="xsm-spec.html#navmodes">Privilege Modes</a>).  An operating system capable of supporting multiprogramming can provide this view to more than one process concurrently. We'll learn about the view of a process in detail in the further sections. </p>
			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>			




			<article  id="navmachineview" class="grid col-full">
				<h2>Machine view of a process</h2>
				<p>
					Every user process has a limited view of the machine. Also it accesses only a limited set of registers and memory. It cannot use certain instructions directly. These instructions are called privileged instructions (See <a href="xsm-spec#navinstr">Instructions</a> in XSM). The privileged instructions are accessed by the user program through system calls (see <a href="xos-spec.html#navsyscalls">System Calls</a>). 
	 			</p>
	 			</article>
 				<article id="navmemory" class="grid col-full">
				<p> <h4>Memory</h4>
				
					In XOS, a process views memory as a contiguous block with starting address 0. The size of the block is 2048 words. However, XSM allocates memory as pages. Each page has 512 words. This means that a process can have use at most 4 pages. Although the user process views this as contiguous 4 pages in memory, it may not be contiguous in the physical memory. The contiguous view that a process gets of the memory is called its <b>Logical address space</b>. When this is mapped to the physical memory, it is called its <b>Physical Address Space</b>. Logical addresses are translated to physical addresses by the machine using the <a href="xos-spec.html#navaddr">Address translation</a> scheme of XSM. The process is unaware of the existence of a physical address space and the address translation mechanism is hidden from it.
				</p>
				 <p><img src="doc/prostruct1.png"></p>
				<p>
					Of the 4 pages that the process uses, the first 3 pages are used for storing the code of the program and the 4th page (address 1535 - 2047) is used as the stack of the process. <b>Stack</b> of a process is a data structure for saving runtime variables, and function call arguments of the process. Read about stack in <a href="#navfncalls" class="subsec" >function calls in APL</a>.
				</p>
				</article>

				<article id="navregisters" class="grid col-full">
				 <p><h4>Registers</h4>
				Although XSM has 34 registers, including program registers, kernel registers, temporary registers and special purpose registers, a particular user process has access to a limited set of registers (See <a href="xsm-spec.html#navregset">Register Set</a> in XSM). The register set that is visible to a user process includes only the Program Registers (R0 - R7), SP, BP and IP. Out of which, IP cannot be read / modified. The SP or Stack Pointer points to the address of the top of the stack. BP will be used in function calls. Read about stack in <a href="#navfncalls" class="subsec" >function calls in APL</a>.  </p>
				
				<p>IP points to the address of the next instruction to be executed within the code. </p>
				</article>

				<article id="navinstr" class="grid col-full">	
				<p> <h4>Instructions</h4>
				
					XSM provides a set of unprivileged instructions. Only these instructions are available to the user program. The user program written in a high level language in APL will compile to only unprivileged instructions. The unprivileged instructions are <tt>MOV</tt>, Arithmetic Instructions, Logic Instructions, Stack Instructions (<tt>PUSH</tt> and <tt>POP</tt>), Sub-routine instructions, input/output instructions, debug instructions, <tt>END</tt> and <tt>INT</tt> (see <a href="xsm-spec.html#navinstr">Instructions</a> in XSM).
				</p>
				</article>
		
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>			
			


			<article  id="navtranslate" class="grid col-full">
				<h2>Translating APL programs</h2>
				<p> APL compiler translates an APL program into XSM machine instructions. There are two fundamental aspects about compilers that you must understand. First is how the APL compiler translates a Function Call. Second is how the APL compiler generates instructions for a system call. </p>
			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>	
			
			<article  id="navfncalls" class="grid col-full">
				<h3>Function Calls</h3>
				<p> A function call or a subroutine invocation is done by the machine instruction <tt>CALL</tt>. The stack to pass arguments to the function and get back the return value. The stack of the user process stores information about the active subroutines of the program. An active subroutine is one that has been called but is yet to complete execution. Control should be handed back to the point of call after completing the function execution.  </p>

				<p> The activation record corresponding to an active subroutine (or the active function) is shown below. The bottom position of the activation record is pointed to by the BP, and the top of the stack is by SP. The region between BP an SP within the stack is the activation record of the active function. See the figure below.</p>
					
					<img src="doc/activationrecord.png" style="width:200px" />
				<br/><br/>
					<p>(<b>NOTE</b> In XOS, stack grows from a lower memory address to a higher memory address. )
				</p>
				<p> The stack contents when a function call is made is shown in the figure below </p>
				<img src="doc/fncall.png" style="width:600px" />
				<br/><br/>
				
				<p><h6>A: When a CALLER function invokes a CALLEE function, a few actions are performed</h6></p>
				<ol>
					<li> The used registers and arguments are pushed into the stack. (See figure)</li>
					<li> An empty space for the return value is pushed, specified as RETURN VALUE in the above figure. The CALLEE function will store the return value in this space after it is computed. </li>
					<li> The <tt>CALL</tt> instruction will push the address of IP specified as <tt>RETURN ADDRESS</tt> into the stack. This is because the <tt>CALL</tt> instruction changes IP to the address of the CALLEE's instructions. After the CALLEE performs its actions it must return back to the point after the function call. Hence the current IP must be backed up</li>
				</ol>
				<p> APL generates instructions doing steps 1 and 2. It also generates the <tt>CALL</tt> instruction which does step 3.
				<p> The activation record for a CALLER function stores its local variables, the arguments it passes to the CALLEE function, the RETURN VALUE and the RETURN ADDRESS.
				<p><h6>B: Actions in the CALLEE function</h6></p>
				<p> The <tt>CALL</tt> instruction passes control to the starting instruction of the CALLEE function. The first few instructions generated by APL in the CALLEE function does the following actions</p>
				<ol>
					<li><p>Push the current value of <b>BP</b> to the stack. The activation record of the active function is identified by BP. When a new function is invoked BP needs to be changed to the base of its activation record. The old value of BP must be backed up in the stack so that it can be reset when it returns back to the CALLER function. </li></p>

					<li><p>The BP is changed to the value on top the stack. </li></p>
					<li><p>The local variables of the APL program will be allocated space in the stack. This is done by incrementing SP. The region between SP and BP is known as the activation record of the CALLEE function</li></p>

				</ol>
					<p><h6>C: Returning from the system call</h6></p>
				The function then performs the required actions, and returns back to the CALLER function.This is done using the <tt>return;</tt> APL instruction which translates to <tt>RET</tt> machine instruciton. The steps done in detail are given below:
				<ol>
					<li> The function stores the return value computed in the space provided in the activation record of the CALLEE function.</li>
					<li> All the local variables of the function are popped from the stack</li>
					<li> <b>OLD BP</b> is popped out from the stack. <b>BP</b> is set to <b>OLD BP</b>. 
					</li> 
					<li> Then the <tt>RET</tt> instruction is generated by the APL. The <tt>RET</tt> instruction sets the IP to the value on top of the stack. Now the top of the stack points to the top of the activation record of the CALLER function. This value, specified as <b>RETURN ADDRESS</b> was pushed by the CALL instruction. When IP is set to this value, it passes control to the instruction after the <tt>CALL</tt> instruction in the CALLER function.</li>
					 <li> The CALLER function obtains the return value from the stack and stores it in a register. It pops out the arguments in its activation record and it is discarded. It also restores the backed up register values. The instructions to do this are generated by APL compiler after the CALL instruction </li>
					
				</ol>
				<p> An example of translating a recursive program to computing the factorial of the number  is shown below</p>
				<div class="syntax"><pre>decl
	integer fact(integer n);	// Declaration of fact() function
enddecl
integer fact(integer n)			// Definition of recursive function fact()
{
	integer f;			// Local variable of fact()
	if(n==1) then			// Checking base case of recursion
		f=1;				
	else
		f=n*fact(n-1);		// Recursive call to fact(n-1)
	endif;
	return f;			// Value of f is returned to the CALLER function
}

integer main()
{
	integer n,result;		// Local variables of main()
	read(n);			// Input is obtained from the user
	result=fact(n);			// Factorial of 'n' is stored in 'result'
	print(result);			// The value of 'result' is printed
	return 0;			// Return from main()
}	</pre>
				</div>
				
				When the above APl program is compiled, the output file generated will contain machine code. The compiled output is shown below (Comments are given for understanding the code. Instruction size is 2 words. Word number is shown on the left for each instruction)
<div class="syntax"><pre>
0:	START
2:	MOV SP, 1535	// Initialize SP to 1535 (Before Logical Page Number 3)
4:	MOV BP, 1535	// Initialize BP to 1535 (Before Logical Page Number 3)
6:	JMP 00110	// Jumps to the main() function (word address 110)

// fact() function definition starts here

8:	PUSH BP		// Old value of BP is pushed
10:	MOV BP, SP	// BP is changed to SP
12:	PUSH R0		// Allocating space for local variable 'f
14:	MOV R0, -3	// Argument 1 is obtained at 3rd position below BP.
16:	MOV R1, BP	// ...
18:	ADD R0, R1	// ...
20:	MOV R0, [R0]	// ...
22:	MOV R1, 1	// Checking if condition and branching		
24:	EQ R0, R1	// ...
26:	JZ R0, 00040	// Jumps to 'else' part if condition is false
28:	MOV R0, 1	// 'if' condition actions
30:	MOV R1, BP	// ...
32:	ADD R0, R1	// ...
34:	MOV R1, 1	// ...
36:	MOV [R0], R1 	// ...
38:	JMP 00088	// Skip 'else' part
40:	MOV R0, 1	// 'else ' condition actions begins here
42:	MOV R1, BP	// ...
44:	ADD R0, R1  	// ...
46:	MOV R1, -3  	// ...
48:	MOV R2, BP  	// ...
50:	ADD R1, R2  	// ...
52:	MOV R1, [R1]	// ...
54:	PUSH R1		// ... Backing up registers
56:	PUSH R0		// ... ...
58:	MOV R0, -3	// ... Calculating argument 'n-1' for recursive call
60:	MOV R1, BP	// ... ...
62:	ADD R0, R1	// ... ...
64:	MOV R0, [R0]	// ... ...
66:	MOV R1, 1	// ... ...
68:	SUB R0, R1	// ... ...
70:	PUSH R0		// ... Push argument 'n-1' to stack
72:	PUSH R0		// ... Push a space for return value before function call
74:	CALL 8		// ... Recursive call to fact(). jumps to address 8
76:	POP R2		// ... Popping out the RETURN VALUE from the stack
78:	POP R3		// ... Popping out the arguments from the stack
80:	POP R0		// ... Popping out the backed up registers from the stack
82:	POP R1		// ... ...
84:	MUL R1, R2	// ... Computing 'f'
86:	MOV [R0], R1	// ...
88:	MOV R0, 1	// Obtaining the value of 'f'
90:	MOV R1, BP	// ...
92:	ADD R0, R1	// ...
94:	MOV R0, [R0]	// ...
96:	MOV R1, -2	// Storing the return value at BP - 2
98:	MOV R2, BP	// ...
100:	ADD R1, R2	// ...
102:	MOV [R1], R0	// ...
104:	POP R0		// Popping out local variable
106:	POP BP		// Popping out OLDBP to BP
108:	RET		// Return from the function fact()

// main() starts here

110:	PUSH BP		// Old value of BP is pushed
112:	MOV BP,SP	// BP is changed to SP
114:	PUSH R0		// Allocating space for local variable 'n'
116:	PUSH R0		// Allocating space for local variable 'result'
118:	MOV R0, 1	// Getting location of 'n' in the stack (BP + 1)
120:	MOV R1, BP	// ...
122:	ADD R0, R1	// ...
124:	IN R1		// Reading 'n' from user
126:	MOV [R0], R1	// Saving the value of 'n' to the stack
128:	MOV R0, 2	// Getting location of 'result' in the stack (BP + 2)
130:	MOV R1, BP	// ...
132:	ADD R0, R1	// ...
134:	PUSH R0		// Backing up registers for function call
136:	MOV R0, 1	// Computing arguments for function call
138:	MOV R1, BP	// ... 
140:	ADD R0, R1	// ...
142:	MOV R0, [R0]	// ...
144:	PUSH R0		// Pushing arguments to stack 
146:	PUSH R0		// Allocating space for RETURN VALUE
148:	CALL 8		// Function call to fact(), jumps to address 8
150:	POP R1		// Popping out the RETURN VALUE from the stack
152:	POP R2		// Popping out the arguments from the stack
154:	POP R0		// Popping out backed up registers
156:	MOV [R0], R1	// Saving the return value in 'result'
158:	MOV R0, 2	// Getting value of 'result'
160:	MOV R1, BP	// ...
162:	ADD R0, R1	// ...
164:	MOV R0, [R0]	// ...
166:	OUT R0		// Printing 'result'
168:	MOV R0, 10	// Preparing for exiting
170:	PUSH R0		// ...
172:	INT 7		// ...
</pre></div>
<p> When the above program is run with value of 'n' as 2 taken from input, the following will be the condition of stack</p>
<a href="doc/fnstack.png" target="blank"><img src="doc/fnstack.png" style="max-width:95%; "/></a>
			</article>
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>		




			<article  id="navsyscalls" class="grid col-full">
				<h3>System Calls</h3>
			<p> System calls are like built in functions in APL. When they are invoked, it generates an INT instruction, which transfers control to location in memory where the system call implementation is present. The system call implementation will be inside an interrupt routine and it has superuser privileges. Read about various <a href="apl-spec.html#navsyscalls">system calls</a> available in APL.</p>
			
			<p> There are three steps in executing a system call. Invoking the system call, performing the system call and after returning from the system call. The instructions to do the first and last steps are generated by APL. Lets understand how APL does the first and last step.</p>

				<h5>Invoking a system call</h5>
				<p>An user process  invokes a system call by first pushing the arguments and system call number into the process stack and then invoking <tt> INT </tt> instruction corresponding to the system call. A system call in APL compiles to the a set of machine instructions like the one shown below.</p>
				<div class="syntax"> <pre>
PUSH <i>Argument_1</i>		// Push arguments to the stack
.
.
PUSH <i>Argument_n</i>
PUSH R0			// Push an empty space for RETURN VALUE
PUSH <i>System_Call_No</i> 	// Push system call number		
INT <i>number</i> 		// Invoke the corresponding INT instruction</div></pre>
				
<p>(NOTE: The machine code above is in the form of pseudo code.)</p>
				
				 <img src="doc/syscallstack1.png" style="width:50%; float:left; margin-right:5%; ">
				 
				<p><b>a) Shows the stack operations performed by the user program before
				 an <tt>INT</tt> instruction in the compiled APL program (See machine instructions above) </b>. The arguments are pushed to stack in an order such that last argument comes on top. A push instruction <tt>PUSH R0</tt> is done to put an empty space for the return value in the stack. The system call implementation must ensure that the return value is stored in this space.  The system call number is pushed to the stack. The system call implementation will require this value to identify the system call. </p>
				
				<p>
				 <b>b)  Shows the contents of the stack after the <tt>INT</tt> instruction is executed </b>. The <tt>INT</tt> instruction will push the value of <tt>IP + 2</tt> on to the stack. This value is the address of the instruction after the <tt>INT</tt> instruction in the user program.  Each instruction is 2 words, hence IP is incremented by 2.This IP value will be used by interrupt routine in order to return back from the system call to the next instruction.  The <tt>INT</tt> instruction changes mode from USER to KERNEL mode and  passes control to the Interrupt Routine corresponding to the system call. </p>
			<br/><br/>

			
				<h5> After returning from the system call. </h5>
				<p> The interrupt routine instruction transfers control back to the user program to the instruction after the <tt>INT</tt> instruction. The following machine instructions are present after the <tt>INT</tt> instruction in the APL compiled machine code given in the previous step. </p>
				<div class="syntax"> <pre>
POP <i>System Call Number </i>	// Pop and discard system call number
POP <i>RETURN_VALUE</i>	// Pop and save the return value
POP <i>Argument_n</i>		// Pop and discard arguments
.
.
POP <i>Argument_1</i></div></pre>	

			<p>(NOTE: The machine code above is in the form of pseudo code. ) </p>

			<p> The machine code above pops the values from the stack. The system call number and arguments were inputs to the system call and hence they may be discarded now. The return value which is stored in the stack by the system call is fetched and used by the user program. </p>
			</article>
			<br/>
			<br/>
			<article  id="navsyscallstranslate" class="grid col-full">
			<h4>System calls and their translation</h4>
			<p>In this section, example APL programs invoking a system call and their translated machine code is shown. The code is commented for better understanding.</p>
			</article>
		
		
		
		
		
			<article  id="navsyscallscreate" class="grid col-full">
			<h5>Create</h5>
			
			
			<div style="width:44%; float:left">
				<i>Description:</i>  Creates a file in the XFS disk<br/>
				<i>System Call No</i>: 1 <br/>
				<i>Interrupt Routine No</i>: 1 <br/>
				<i>Arguments</i>: filename <br/>
				<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
				
				<div class="syntax"><pre>
// <b>APL program to invoke Create</b>

integer main()
{	
	integer a;
	a = Create("File");
	return 0;
}</pre>
				</div>
			</div>


			<div class="syntax" style="width:52%; float:right"><pre>
// <b>Compiled XSM machine code</b>

START		
MOV SP, 1535	// Initializes SP to 1535
MOV BP, 1535	// Initializes BP to 1535
JMP 00008	// Jump to main() function

// main() function
//================
PUSH BP		
MOV BP,SP
PUSH R0		// Space for 'a' in stack
MOV R0, 1	
MOV R1, BP
ADD R0, R1
// preparing stack for system call
MOV R1, "File"	// Pushing argument filename
PUSH R1		// ...
PUSH R0		// Pushing space for RETURN VALUE
MOV R1, 1	// Pushing system call number = 1
PUSH R1		// ...
// invoking interrupt routine
INT 1		// Transfers control to interrupt 1
// The interrupt routine returns back here 
POP R2		// Pop out system call number
POP R1		// Pop out return value
POP R2		// Pop out the argument 
MOV [R0], R1	// Saving the return value in 'a'
MOV R0, 10	// Preparing for exit system call
PUSH R0		// ...
INT 7		// Invoking interrupt  7 (exit)</pre></div>		

			</article>






			<article  id="navsyscallsopen" class="grid col-full">
			<h5>Open</h5>
			
			<div style="width:44%; float:left">
				<i>Description:</i> The Open system call is used to open a file present in the XFS disk. <br/>
				<i>System Call No</i>: 2 <br/>
				<i>Interrupt Routine No</i>: 2 <br/>
				<i>Arguments</i>: filename of the file to be opened <br/>
				<i>Return Value</i>: Index of open instance in Per-Process Open File table (Success) or -1 (Failure) <br/>
				<div class="syntax"><pre>
// <b>APL program to invoke Open</b>

integer main()
{	
	integer a;
	a = Open("File");
	return 0;
}</pre>
				</div>
			</div>
			<div class="syntax" style="width:52%; float:right"><pre>
// <b>Compiled XSM machine code</b>

START		
MOV SP, 1535	// Initializes SP to 1535
MOV BP, 1535	// Initializes BP to 1535
JMP 00008	// Jump to main() function

// main() function
//================
PUSH BP		
MOV BP,SP
PUSH R0		// Space for 'a' in stack
MOV R0, 1	
MOV R1, BP
ADD R0, R1
// preparing stack for system call
MOV R1, "File"	// Pushing argument filename
PUSH R1		// ...
PUSH R0		// Pushing space for RETURN VALUE
MOV R1, 2	// Pushing system call number = 2
PUSH R1		// ...
// invoking interrupt routine
INT 2		// Transfers control to interrupt 2
// The interrupt routine returns back here 
POP R2		// Pop out system call number
POP R1		// Pop out return value
POP R2		// Pop out the argument 
MOV [R0], R1	// Saving the return value in 'a'
MOV R0, 10	// Preparing for exit system call
PUSH R0		// ...
INT 7		// Invoking interrupt  7 (exit)</pre></div>			

			</article>
			
			
			
			
			<article  id="navsyscallsclose" class="grid col-full">
			<h5>Close</h5>
			
			<div style="width:44%; float:left">
			<i>Description</i>: Closes a file opened by the process.<br/>
			<i>System Call No</i>: 3 <br/>
			<i>Interrupt Routine No</i>: 2 <br/>
			<i>Arguments</i>: fileDescriptor <br/>
			<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>			
			<div class="syntax"><pre>
// <b>APL program to invoke Close</b>

integer main()
{	
	integer a;
	a = Close(0);
	return 0;
}</pre>			</div>
			</div>

			<div class="syntax" style="width:51%; float:right"><pre>
// <b> Compiled XSM machine code</b>

START		
MOV SP, 1535	// Initializes SP to 1535
MOV BP, 1535	// Initializes BP to 1535
JMP 00008	// Jump to main() function

// main() function
//================
PUSH BP		
MOV BP,SP
PUSH R0		// Space for 'a' in stack
MOV R0, 1	
MOV R1, BP
ADD R0, R1
// preparing stack for system call
MOV R1, 0	// Pushing argument fileDescriptor
PUSH R1		// ...
PUSH R0		// Pushing space for RETURN VALUE
MOV R1, 3	// Pushing system call number = 3
PUSH R1		// ...
// invoking interrupt routine
INT 2		// Transfers control to interrupt 2
// The interrupt routine returns back here 
POP R2		// Pop out system call number
POP R1		// Pop out return value
POP R2		// Pop out the argument 
MOV [R0], R1	// Saving the return value in 'a'
MOV R0, 10	// Preparing for exit system call
PUSH R0		// ...
INT 7		// Invoking interrupt  7 (exit)</pre></div>			

			</article>
			
			
			
			
			<article  id="navsyscallsdelete" class="grid col-full">
			<h5>Delete</h5>
			
			<div style="width:44%; float:left">
			<i>Description:</i> Deletes a file in the disk with the filename given as argument. <br/>
			<i>System Call No</i>: 4 <br/>
			<i>Interrupt Routine No</i>: 1 <br/>
			<i>Arguments</i>: filename <br/>
			<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>					
			<div class="syntax"><pre>
// <b>APL program to invoke Delete</b>

integer main()
{	
	integer a;
	a = Delete("File");
	return 0;
}</pre></div>
			</div>
			<div class="syntax" style="width:52%; float:right"><pre>
// <b> Compiled XSM machine code</b>

START		
MOV SP, 1535	// Initializes SP to 1535
MOV BP, 1535	// Initializes BP to 1535
JMP 00008	// Jump to main() function

// main() function
//================
PUSH BP		
MOV BP,SP
PUSH R0		// Space for 'a' in stack
MOV R0, 1	
MOV R1, BP
ADD R0, R1
// preparing stack for system call
MOV R1, "File"	// Pushing argument filename
PUSH R1		// ...
PUSH R0		// Pushing space for RETURN VALUE
MOV R1, 4	// Pushing system call number = 4
PUSH R1		// ...
// invoking interrupt routine
INT 1		// Transfers control to interrupt 1
// The interrupt routine returns back here 
POP R2		// Pop out system call number
POP R1		// Pop out return value
POP R2		// Pop out the argument 
MOV [R0], R1	// Saving the return value in 'a'
MOV R0, 10	// Preparing for exit system call
PUSH R0		// ...
INT 7		// Invoking interrupt  7 (exit)</pre></div>			

			</article>
			

			<article  id="navsyscallswrite" class="grid col-full">
			<h5>Write</h5>
			
			<div style="width:44%; float:left">
			<i>Description:</i> Used to write a single word to a file opened by the process<br/>
			<i>System Call No</i>: 5 <br/>
			<i>Interrupt Routine No</i>: 4 <br/>
			<i>Arguments</i>: 1. fileDescriptor, 2. wordToWrite <br/>
			<i>Return Value</i>: 0 (Success) or -1 (Failure) </br>
			<div class="syntax"><pre>
// <b>APL program to invoke Write</b>

integer main()
{	
	integer a;
	a = Write(0,a);
	return 0;
}</pre></div>		</div>
			<div class="syntax" style="width:52%; float:right"><pre>
// <b> Compiled XSM machine code</b>

START		
MOV SP, 1535	// Initializes SP to 1535
MOV BP, 1535	// Initializes BP to 1535
JMP 00008	// Jump to main() function

// main() function
//================
PUSH BP		
MOV BP,SP
PUSH R0		// Space for 'a' in stack
MOV R0, 1	
MOV R1, BP
ADD R0, R1
// Preparing for system calls
MOV R1, 0	// Pushing argument 0
PUSH R1		// ...
MOV R1, 1	// Pushing argument a
MOV R2, BP	// ...
ADD R1, R2	// ...
MOV R1, [R1]	// ...
PUSH R1		// ...
PUSH R0		// Pushing space for RETURN VALUE
MOV R1, 5	// Pushing system call number = 5
PUSH R1		// ...
// invoking interrupt routine
INT 4		// Transfers control to interrupt 4
// The interrupt routine returns back here 
POP R2		// Pop out system call number
POP R1		// Pop out return value
POP R2		// Pop out arguments
POP R2		// ...
MOV [R0], R1	// Store the return value in 'a'
MOV R0, 10	// Preparing for exit system call
PUSH R0		// ...
INT 7		// Invoking interrupt  7 (exit)</pre></div>			

			</article>
			
			
			
			
			<article  id="navsyscallsseek" class="grid col-full">
			<h5>Seek</h5>
			<div style="width:44%; float:left">
			<i>Description</i>: Changes the LSEEK position<br/>
			<i>System Call No</i>: 6 <br/>
			<i>Interrupt Routine No</i>: 3 <br/>
			<i>Arguments</i>: 1. fileDescriptor 2. newLseek <br/>
			<i>Return Value</i>: 0 (Success) or -1 (Failure) <br/>			
			<div class="syntax"><pre>
// <b>APL program to invoke Seek</b>

integer main()
{	
	integer a;
	a = Seek(0,10);
	return 0;
}</pre></div>		</div>
			<div class="syntax" style="width:52%; float:right"><pre>
// <b> Compiled XSM machine code</b>

START		
MOV SP, 1535	// Initializes SP to 1535
MOV BP, 1535	// Initializes BP to 1535
JMP 00008	// Jump to main() function

// main() function
//================
PUSH BP		
MOV BP,SP
PUSH R0		// Space for 'a' in stack
MOV R0, 1	
MOV R1, BP
ADD R0, R1
// Preparing for system calls
MOV R1, 0	// Pushing argument 0
PUSH R1		// ...
MOV R1, 10	// Pushing argument 10
PUSH R1		// ...
PUSH R0		// Pushing space for RETURN VALUE
MOV R1, 6	// Pushing system call number = 6
PUSH R1		// ...
// invoking interrupt routine
INT 3		// Transfers control to interrupt 3
// The interrupt routine returns back here 
POP R2		// Pop out system call number
POP R1		// Pop out return value
POP R2		// Pop out arguments
POP R2		// ...
MOV [R0], R1	// Store the return value in 'a'
MOV R0, 10	// Preparing for exit system call
PUSH R0		// ...
INT 7		// Invoking interrupt  7 (exit)	</pre></div>			

			</article>
			
			
						
			<article  id="navsyscallsread" class="grid col-full">
			<h5>Read</h5>
			<div style="width:44%; float:left">
			<i>Description</i>: Reads a word from a file to the variable passed as argument. <br/>
			<i>System Call No</i>: 7 <br/>
			<i>Interrupt Routine No</i>: 3 <br/>
			<i>Arguments</i>: 1) fileDescriptor 2) wordRead<br/>
			<i>Return Value</i>: 0 (success) and -1 (failure) </br>			
			<div class="syntax"><pre>
// <b>APL program to invoke Read</b>

integer main()
{	
	integer a;// FileDescriptor
	string b;// Word read will be here
	a = Read(0,b);
	return 0;
}</pre></div>		</div>
			<div class="syntax" style="width:52%; float:right"><pre>
// <b> Compiled XSM machine code</b>


START		
MOV SP, 1535	// Initializes SP to 1535
MOV BP, 1535	// Initializes BP to 1535
JMP 00008	// Jump to main() function

// main() function
//================
PUSH BP		
MOV BP,SP
PUSH R0		// Space for 'a' in stack
PUSH R0		// Space for 'b' in stack
MOV R0, 1	
MOV R1, BP
ADD R0, R1
// Preparing for system calls
MOV R1, 0	// Pushing argument 0
PUSH R1		// ...
MOV R1, 2	// Pushing argument b
MOV R2, BP	// ...
ADD R1, R2	// ...
MOV R1, [R1]	// ...
PUSH R1		// ...
PUSH R0		// Pushing space for RETURN VALUE
MOV R1, 7	// Pushing system call number = 5
PUSH R1		// ...
// invoking interrupt routine
INT 3		// Transfers control to interrupt 3
// The interrupt routine returns back here 
POP R2		// Pop out system call number
MOV R1, 2	// Get the location on 'b'
MOV R2, BP	// ...
ADD R1, R2	// ...
POP R2		// Pop out the RETURN VALUE
// Argument 'b' was passed as reference.
POP R3		// Pop and save argument to 'b'
MOV [R1], R3	// ...
MOV R1, R2	// ...
POP R2		// Pop out argument 0
MOV [R0], R1	// Store the return value in 'a'
MOV R0, 10	// Preparing for exit system call
PUSH R0		// ...
INT 7		// Invoking interrupt  7 (exit)</pre></div>			

			</article>		
			
			
			
			
			
			
			<article  id="navsyscallsfork" class="grid col-full">
			<h5>Fork</h5>
			<div style="width:44%; float:left">
			<i>Description</i>: Replicates the process which invoked this system call in the memory. <br/> 
			<i>System Call No</i>: 8 <br/>
			<i>Interrupt Routine No</i>: 5 <br/>
			<i>Arguments</i>: None<br/>
			<i>Return Value</i>: In the parent process, PID of the process created (success) or -1 (failure). In the child process, -2 <br/>			
			<div class="syntax"><pre>
// <b>APL program to invoke Fork</b>

integer main()
{	
	integer a;
	a = Fork();
	return 0;
}</pre></div>		</div>
			<div class="syntax" style="width:52%; float:right"><pre>
// <b> Compiled XSM machine code</b>

START		
MOV SP, 1535	// Initializes SP to 1535
MOV BP, 1535	// Initializes BP to 1535
JMP 00008	// Jump to main() function

// main() function
//================
PUSH BP		
MOV BP,SP
PUSH R0		// Space for 'a' in stack
MOV R0, 1	
MOV R1, BP
ADD R0, R1
MOV R0, -2
// Preparing for system calls
PUSH R0		// Pushing space for RETURN VALUE
MOV R1, 8	// Pushing system call number = 5
PUSH R1		// ...
// invoking interrupt routine
INT 5		// Transfers control to interrupt 5
// The interrupt routine returns back here 
POP R2		// Pop out system call number
POP R1		// Pop out the RETURN VALUE
MOV [R0], R1	// Store the return value in 'a'
MOV R0, 10	// Preparing for exit system call
PUSH R0		// ...
INT 7		// Invoking interrupt  7 (exit)</pre></div>			

			</article>
			
			
			
			
			<article  id="navsyscallsexec" class="grid col-full">
			<h5>Exec</h5>
			
			<div style="width:44%; float:left">
			<i>Description:</i> used to load and run a new process from a currently running process. The current process is overwritten by new process i.e. the process data structures and memory of the current process is used by the new process. </br>
			<i>System Call No</i>: 9 <br/>
			<i>Interrupt Routine No</i>: 6 <br/>
			<i>Arguments</i>: filename <br/>
			<i>Return Value</i>: 0 (success) and -1 (failure) </br>			
			<div class="syntax" ><pre>
// <b>APL program to invoke Exec</b>

integer main()
{	
	integer a;
	a = Exec("File");
	return 0;
}</pre></div>		</div>
			<div class="syntax" style="width:52%; float:right"><pre>
// <b> Compiled XSM machine code</b>

START		
MOV SP, 1535	// Initializes SP to 1535
MOV BP, 1535	// Initializes BP to 1535
JMP 00008	// Jump to main() function

// main() function
//================
PUSH BP		
MOV BP,SP
PUSH R0		// Space for 'a' in stack
MOV R0, 1	
MOV R1, BP
ADD R0, R1
// preparing stack for system call
MOV R1, "File"	// Pushing argument filename
PUSH R1		// ...
PUSH R0		// Pushing space for RETURN VALUE
MOV R1, 9	// Pushing system call number = 9
PUSH R1		// ...
// invoking interrupt routine
INT 6		// Transfers control to interrupt 6
// The interrupt routine returns back here 
POP R2		// Pop out system call number
POP R1		// Pop out return value
POP R2		// Pop out the argument 
MOV [R0], R1	// Saving the return value in 'a'
MOV R0, 10	// Preparing for exit system call
PUSH R0		// ...
INT 7		// Invoking interrupt  7 (exit)</pre></div>			

			</article>
			
			
			
			
			<article  id="navsyscallsexit" class="grid col-full">
			<h5>Exit</h5>
			<div style="width:44%; float:left">
			<i>Description</i>: <br/>Terminate the execution of the process which invoked it. Exit removes this process from the memory. If there is only one process, it halts the system.<br/>
			<i>System Call No</i>: 10 <br/>
			<i>Interrupt Routine No</i>: 7 <br/>
			<i>Arguments</i>: None<br/>
			<i>Return Value</i>:-1 on failure, exits on success </br>			
			<div class="syntax" ><pre>
// <b>APL program to invoke Exit</b>

integer main()
{	
	Exit();
	return 0;
}</pre></div>		</div>
			<div class="syntax" style="width:52%; float:right"><pre>
// <b> Compiled XSM machine code</b>

START		
MOV SP, 1535	// Initializes SP to 1535
MOV BP, 1535	// Initializes BP to 1535
JMP 00008	// Jump to main() function

// main() function
//================
PUSH BP		
MOV BP,SP
// preparing stack for the system call
MOV R0, 10	// Pushing system call number = 10
PUSH R0		// ...
// invoking interrupt routine
INT 7		// Transfers control to interrupt 7
// Ideally, it should exit this process and stops execution
POP R0		// Executed, only if exit fails.
MOV R0, 10	// Exit() is also added at the end by APL
PUSH R0		// ...
INT 7		// ...</pre></div>			

			</article>
			
			
			
			
			
			<article  id="navsyscallshalt" class="grid col-full">
			<h5>Halt</h5>
			<div style="width:44%; float:left">
			<i>Description</i>: <br/> If there is only one process in memory, it halts the system. Otherwise returns -1, indicating error. <br/>
			<i>System Call No</i>: 0 <br/>
			<i>Interrupt Routine No</i>: 7 <br/>
			<i>Arguments</i>: None<br/>
			<i>Return Value</i>:-1 on failure, halts on success </br>			
			<div class="syntax"><pre>
// <b>APL program to invoke Halt</b>

integer main()
{	
	Halt();
	return 0;
}</pre></div>		</div>
			<div class="syntax" style="width:52%; float:right"><pre>
// <b> Compiled XSM machine code</b>

START		
MOV SP, 1535	// Initializes SP to 1535
MOV BP, 1535	// Initializes BP to 1535
JMP 00008	// Jump to main() function

// main() function
//================
PUSH BP		
MOV BP,SP
// preparing stack for the system call
MOV R0, 0	// Pushing system call number = 0
PUSH R0		// ...
// invoking interrupt routine
INT 7		// Transfers control to interrupt 7
POP R0		// If not halted, pops the system call number
MOV R0, 10	// Exit() is added at the end by APL
PUSH R0		// ...
INT 7		// ...</pre></div>			

			</article>
			
			
			
			
			<div class="up grid col-one-third" style="float:right">
			<a href="#navtop" title="Go back up"> top &uarr;</a>
			</div>		
			</div> <!-- 100%articles-->

		
		</section>	
		
		
	</div> <!--main-->
<div class="divide-top">
	<footer class="grid-wrap">
		<ul class="grid col-one-third social">
			<li><a href="http://github.com/xosnitc">Github</a></li>
		</ul>
	
		<div class="up grid col-one-third ">
			<a href="#navtop" title="Go back up">&uarr;</a>
		</div>
		
		<nav class="grid col-one-third ">
			<ul><li><a href="index.html" >Home</a></li>
				<li><a href="about.html">About</a></li>
				<li><a href="documentation.html">Documentation</a></li>
				<li><a href="downloads.html">Downloads</a></li>
				<li><a href="roadmap.html">Roadmap</a></li></ul>
			</ul>
		</nav>
	</footer>
</div>

</div>

<!-- Javascript - jQuery -->
<script src="http://code.jquery.com/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="js/jquery-1.7.2.min.js"><\/script>')</script>

<!--[if (gte IE 6)&(lte IE 8)]>
<script src="js/selectivizr.js"></script>
<![endif]-->

<script src="js/scripts.js"></script>

<!-- Asynchronous Google Analytics snippet. Change UA-XXXXX-X to be your site's ID. -->
<script>
  var _gaq=[['_setAccount','UA-XXXXX-X'],['_trackPageview']];
  (function(d,t){var g=d.createElement(t),s=d.getElementsByTagName(t)[0];
  g.src=('https:'==location.protocol?'//ssl':'//www')+'.google-analytics.com/ga.js';
  s.parentNode.insertBefore(g,s)}(document,'script'));
</script>
</body>
</html>
